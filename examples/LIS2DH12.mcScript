'LIS2DH12 accelerometer library
'Written by jwolf @ mcThings
'Modified by Nick Waterton 19th Oct 2016
'AOI is Accelerator Orientation Interrupt (I believe)
'Huh - no it isn't, it means AndOr Interrupts (possibly Inertial?), ether OR interrupts, or AND them (ie x Or y Or z Or Click ...)

// see Data Sheet at http://www.st.com/resource/en/datasheet/lis2dh12.pdf for details

// N Waterton 14th January 2017 V1.4: Beta Release - General mods
// N Waterton 22nd January 2017 V1.5: First Release - Massive re-write NOTE: Could be breaking changes!
// N Waterton 23rd January 2017 V1.51: First Release - Minor mods to interrupt feedback functions, plus one bug fix (enable interrupts)
// N Waterton 24th January 2017 V1.52: First Release - Minor mods to click interrupt feedback functions
// N Waterton 25th January 2017 V1.53: First Release - New functions for pitch/roll, low pass filter etc.

// All functions except FIFO supported.
// eg: motion, transient, freefall, orientation, click (double or single)
// Easy convenience funtions for above setups (plus many other config options)
// support for int 1 or int 2, on pin 1 or 2, latched or unlatched (default is interrupt 1 on pin 1, latched)
// pin 1 = AccelerometerInt1()
// pin 2 = AccelerometerInt2()
// easy read functions for all above modes
// Modes: Low Power = 8 bit, Normal = 10 bit, High Resolution = 12 bit
// Temperature sensor is fairly useless, use it at your own risk!
// NOTE: The on board temp sensor only measures varience against a reference temperature (temp_reference default 25)
//       which you would have to calibrate in order to get an absolute temperature. Resolution is 1 deg C
//       as such, you are better off using the module high resolution temperature sensor.

Class LIS2DH12
    'Constants
    Const VERSION As Integer = 5
    Const MINOR_VERSION As Integer = 3
    Const VERSION_STRING As String = "V1.53"
    
    'I2C constants
    Const LIS2DH12_I2C_ADDR As Byte = 0x19
    Const I2C_SPEED As Integer = 250000
    
    'LIS2DH12 registers
    Const STATUS_REG_AUX As Byte = 0x07
    Const OUT_TEMP_L As Byte = 0x0c
    Const OUT_TEMP_H As Byte = 0x0d
    Const WHO_AM_I As Byte = 0x0f
    Const TEMP_CFG As Byte = 0x1f
    Const CTRL_REG1 As Byte = 0x20
    Const CTRL_REG2 As Byte = 0x21
    Const CTRL_REG3 As Byte = 0x22
    Const CTRL_REG4 As Byte = 0x23
    Const CTRL_REG5 As Byte = 0x24
    Const CTRL_REG6 As Byte = 0x25
    Const REF_DATA_CAP As Byte = 0x26	
    Const STATUS As Byte = 0x27
    Const OUT_X_L As Byte = 0x28
    Const OUT_X_H As Byte = 0x29
    Const OUT_Y_L As Byte = 0x2a
    Const OUT_Y_H As Byte = 0x2b
    Const OUT_Z_L As Byte = 0x2c
    Const OUT_Z_H As Byte = 0x2d
    Const FIFO_CTRL As Byte = 0x2e
    Const FIFO_SRC As Byte = 0x2f
    Const INT1_CFG As Byte = 0x30
    Const INT1_SRC As Byte = 0x31
    Const INT1_THS As Byte = 0x32
    Const INT1_DURATION As Byte = 0x33
    Const INT2_CFG As Byte = 0x34
    Const INT2_SRC As Byte = 0x35
    Const INT2_THS As Byte = 0x36
    Const INT2_DURATION As Byte = 0x37
    Const CLICK_CFG As Byte = 0x38
    Const CLICK_SRC As Byte = 0x39
    Const CLICK_THS As Byte = 0x3a
    Const TIME_LIMIT As Byte = 0x3b
    Const TIME_LATENCY As Byte = 0x3c
    Const TIME_WINDOW As Byte = 0x3d
    Const ACT_THS As Byte = 0x3e
    Const ACT_DUR As Byte = 0x3f
    
    'Temperature constants
    Const TEMP_ENABLE As Byte = 0xc0
    Const TOR As Byte = 0x40
    Const TDA As Byte = 0x04
    
    'Data Available constants
    Const ZYXOR As Byte = 0x80
    Const ZOR As Byte = 0x40
    Const YOR As Byte = 0x20
    Const XOR As Byte = 0x10
    Const ZYXDA As Byte = 0x08
    Const ZDA As Byte = 0x04
    Const YDA As Byte = 0x02
    Const XDA As Byte = 0x01
    
    'Data rate constants
    Const DATA_RATE_POWER_DOWN As Byte = 0x00
    Const DATA_RATE_1HZ As Byte = 0x01
    Const DATA_RATE_10HZ As Byte = 0x02
    Const DATA_RATE_25HZ As Byte = 0x03
    Const DATA_RATE_50HZ As Byte = 0x04
    Const DATA_RATE_100HZ As Byte = 0x05
    Const DATA_RATE_200HZ As Byte = 0x06
    Const DATA_RATE_400HZ As Byte = 0x07
    Const DATA_RATE_1620HZ_LP As Byte = 0x08
    Const DATA_RATE_1344HZ As Byte = 0x09
    Const DATA_RATE_MASK As Byte = 0xf0
    
    'Scale Constants
    Const SCALE_2G As Byte = 0x00
    Const SCALE_4G As Byte = 0x01
    Const SCALE_8G As Byte = 0x02
    Const SCALE_16G As Byte = 0x03
    Const SCALE_MASK As Byte = 0x30
    Const UNDEFINED As Byte = 0xff
    
    'Operating Mode
    Const LOW_POWER_MODE As Byte = 0x01
    Const NORMAL_MODE As Byte = 0x02
    Const HIGH_RESOLUTION_MODE As Byte = 0x03
    
    Const LPEN_BIT As Byte = 0x08
    Const HR_BIT As Byte = 0x08
    
    'Block data and Data Endian bits
    Const BDU_BIT As Byte = 0x80
    Const BLE_BIT As Byte = 0x40
    
    Const CTL5_MASK As Byte = 0xcf
    Const RST_MASK As Byte = 0x80
    Const BOOT As Byte = 0x80
    Const FIFO_EN As Byte = 0x40
    Const LIR_INT1 As Byte = 0x08
    Const D4D_INT1 As Byte = 0x04
    Const LIR_INT2 As Byte = 0x02
    Const D4D_INT2 As Byte = 0x01
    
    Const CTL6_MASK As Byte = 0xfa
    Const I2_CLICKen As Byte = 0x80
    Const I2_INT1 As Byte = 0x40
    Const I2_INT2 As Byte = 0x20
    Const BOOT_I2 As Byte = 0x10
    Const P2_ACT As Byte = 0x08
    Const H_LACTIVE As Byte = 0x02
    
    'Interrupt constants
    Const INT1_ENABLE_MASK As Byte = 0xfe
    Const INT1_CLICK_BIT As Byte = 0x80
    Const INT1_AOI1_BIT As Byte = 0x40
    Const INT1_AOI2_BIT As Byte = 0x20
    Const INT1_DRDY1_BIT As Byte = 0x10
    Const INT1_DRDY2_BIT As Byte = 0x08
    Const INT1_WTM_BIT As Byte = 0x04
    Const INT1_OVERRUN_BIT As Byte = 0x02
    Const INT1_PIN As Byte = 0x01
    Const INT2_PIN As Byte = 0x02
    
    Const INT_ACTIVE As Byte = 0x40
    Const INT_SRC_ZH As Byte = 0x20
    Const INT_SRC_ZL As Byte = 0x10
    Const INT_SRC_YH As Byte = 0x08
    Const INT_SRC_YL As Byte = 0x04
    Const INT_SRC_XH As Byte = 0x02
    Const INT_SRC_XL As Byte = 0x01
    
    //HP Filter mode
    Const HP_FILTER_MASK As Byte = 0xff
    Const HP_FILTER_MODE_MASK As Byte = 0xc0
    Const HP_FILTER_NORMAL_MODE_RESET As Byte = 0x00 '(reset by reading REFERENCE/DATACAPTURE (26h) register)
    Const HP_FILTER_REF_MODE As Byte = 0x01
    Const HP_FILTER_NORMAL_MODE As Byte = 0x02
    Const HP_FILTER_NORMAL_MODE_AUTO As Byte = 0x03 'Autoreset on interrupt event
    //HP Filter bypass
    Const HP_FILTER_BYPASS_BIT As Byte = 0x08
    //HP Interrupts bits mask
    Const HP_FILTER_BITS_MASK As Byte = 0x07
    //HP Filter Enable for click
    Const HP_INT_CLICK_BIT As Byte = 0x04
    //HP Filter Enable AOI int 2
    Const HP_INT_AOI2_BIT As Byte = 0x02
    //HP Filter Enable AOI int 1
    Const HP_INT_AOI1_BIT As Byte = 0x01
    
    
    'HP filter Range
    Const HP_CUTOFF_MASK As Byte = 0x30
    Const HP_CUTOFF_HIGH As Byte = 0x00
    Const HP_CUTOFF_MED As Byte = 0x01
    Const HP_CUTOFF_LOW As Byte = 0x02
    Const HP_CUTOFF_VERY_LOW As Byte = 0x03
    
    'Click Configuration
    Const ZD As Byte = 0x20
    Const ZS As Byte = 0x10
    Const YD As Byte = 0x08
    Const YS As Byte = 0x04
    Const XD As Byte = 0x02
    Const XS As Byte = 0x01
    
    'Click Source
    Const CLICK_IA As Byte = 0x40
    Const DClick As Byte = 0x20
    Const SClick As Byte = 0x10
    Const Sign As Byte = 0x08
    Const CLICK_Z As Byte = 0x04
    Const CLICK_Y As Byte = 0x02
    Const CLICK_X As Byte = 0x01
    
    'Click Latch Interrupt
    Const LIR_Click As Byte = 0x80 'dont know if this exists - totally missing from the datasheet
    
    'AOI / 6D configuration
    Const INT_AOI_MASK As Byte = 0xc0
    Const INT_AOI_BIT As Byte = 0x80
    Const INT_6D_BIT As Byte = 0x40
    
    //limits
    Const LOW_TRIGGER_THRESHOLD As Float = 1.0
    Const HIGH_TRIGGER_THRESHOLD As Float = 23.622
    Const LSB_RESOLUTION_THRESHOLD As Float = 0.186
    
    Const LOW_DURATION_MS As Float = 0.0
    Const HIGH_DURATION_MS As Float = 635.0
    Const DURATION_RESOLUTION As Float = 5.0
    
    'mode scale factor constants
    Const LP_FACTOR As Float = 16.0
    Const NM_FACTOR As Float = 4.0
    'HR factor is 1.0
    
    'Axis constants
    Const X_AXIS As Byte = 0x01
    Const Y_AXIS As Byte = 0x02
    Const Z_AXIS As Byte = 0x04
    
    'Options for json returns
    Const J_NONE As Byte = 0x00
    Const J_VALUES As Byte = 0x01
    Const J_SUMMARY As Byte = 0x02
    
    'Public variables
    Public online As Boolean = False
    Public temp_reference As Integer = 25 'reference temperature for temp sensor
    
    'Private variables
    Private gAccelerometer As I2c
    Private gScale As Byte = UNDEFINED
    Private gOperatingMode As Byte = UNDEFINED
    Private gDataRate As Byte = UNDEFINED
    Private gint1cfg As Byte = UNDEFINED
    Private gint2cfg As Byte = UNDEFINED
    
    Public Sub New()
        'Initialize Objects
        gAccelerometer = I2c.Create(I2C_SPEED, Pin.SCL, Pin.SDA, LIS2DH12_I2C_ADDR)
        Power_Cycle() 'turn accelerometer off, then on, and wait for boot.
        If GetID() = 0x33 Then
            online = True
        End If
    End Sub
    
    Public Function map_range(var As Float, old_min As Float, old_max As Float, new_min As Byte, new_max As Byte) As Byte
        'Convert floats to byte range
        Dim old_range As Float = old_max - old_min
        Dim new_range As Float = new_max - new_min
        Return ((((var - old_min) * new_range) / old_range) + new_min).ToByte
    End Function
    
    Public Function map_range(var As Float, old_min As Byte, old_max As Byte, new_min As Float, new_max As Float) As Float
        'convert bytes to floats range
        Dim old_range As Float = old_max - old_min
        Dim new_range As Float = new_max - new_min
        Return ((((var - old_min) * new_range) / old_range) + new_min).ToFloat
    End Function
    
    Public Sub Power_Cycle()
        'Power cycle accelerometer
        Device.DisableAccelerometer()
        'delay 5ms
        Thread.Delay(5000)
        Device.EnableAccelerometer()
        'delay 20ms to accelerometer to boot
        Thread.Delay(20000)
    End Sub
    
    Public Sub reset()
        Write(CTRL_REG5, RST_MASK)
        Thread.Delay(6000)
    End Sub
    
    Public Sub disable()
        'set accelerometer to DATA_RATE_POWER_DOWN (minnimum power).
        'Values read will be the last valid reading, no new updates, or interrupts generated
        gDataRate = GetDataRate() 'save current data rate
        SetDataRate(DATA_RATE_POWER_DOWN)
    End Sub
    
    Public Sub enable()
        If gDataRate = UNDEFINED Or gDataRate = DATA_RATE_POWER_DOWN Then
            Return
        End If
        SetDataRate(gDataRate) 'restore previous data rate
        Thread.Sleep((GetmsFromDataRate() * 1000).ToInteger)
    End Sub
    
    //temperature functions
    
    Public Sub EnableTemperature(temp As Boolean)
        //bits 6,7 - rest not used
        'Temperature sensor (T) enable. Default value: 00
        '(00: T disabled; 11: T enabled)
        Dim enable As Byte = 0
        If temp Then
            enable = TEMP_ENABLE
            SetBlockData(BDU_BIT) //enable block data update (required for temp reading) - but a good idea anyway
        Else
            enable = 0x00
        End If
        Write(TEMP_CFG, enable) // write bits 6,7
    End Sub
    
    Public Function GetTemperatureEnabled() As Boolean
        //bits 6,7
        'Temperature sensor (T) enable. Default value: 00
        '(00: T disabled; 11: T enabled)
        If ((Read(TEMP_CFG) & TEMP_ENABLE).ToBoolean) And ((GetBlockData() & BDU_BIT).ToBoolean) Then
            Return True
        Else
            Return False
        End If
    End Function
    
    Public Sub SetTemperatureBits(temp As Byte)
        //bits 6,7 - rest not used
        'Temperature sensor (T) enable. Default value: 00
        '(00: T disabled; 11: T enabled)
        Write(TEMP_CFG, temp) // write bits 6,7
    End Sub
    
    Public Function GetTemperatureBits() As Byte
        //bits 6,7
        'Temperature sensor (T) enable. Default value: 00
        '(00: T disabled; 11: T enabled)
        Return (Read(TEMP_CFG) & TEMP_ENABLE)
    End Function
    
    Public Function GetTemperatureStatus() As Byte
        'TOR Temperature data overrun. Default value: 0
        '(0: no overrun has occurred; 1: new temperature data has overwritten the previous data)
        'TDA Temperature new data available. Default value: 0
        '(0: new temperature data is not yet available; 1: new temperature data is available)
        Return (Read(STATUS_REG_AUX) & (TOR | TDA))
    End Function
    
    Public Function NewTemperatureAvailable() As Boolean
        Return GetTemperatureStatus().ToBoolean
    End Function
    
    Public Function GetTemp() As Integer
        'Both the OUT_TEMP_L (0Ch), OUT_TEMP_H (0Dh) registers must be read.
        'Temperature data is stored inside OUT_TEMP_H as two’s complement data in 8-bit format
        'left-justified.
        'NOTE: The on board temp sensor only measure varience against a reference temperature (default 25)
        'which you would have to calibrate in order to get an absolute temperature. Resolution is 1 deg C
        'as such, you are better off using the module high resolution temperature sensor.
        
        Dim Data As ListOfByte = New ListOfByte
        Data = Read(OUT_TEMP_L, 2)
        Dim Temp As Integer = temp_reference + Data(1).SignExtend()
        Return Temp
    End Function
    
    Public Function GetNewTemp() As Integer
        'Enables temperature (if not already enabled
        'waits for new reading
        'returns new reading
        If GetDataRate() = DATA_RATE_POWER_DOWN Then
            Return Integer.MinValue 'invalid data
        End If
        
        If Not GetTemperatureEnabled() Then
            EnableTemperature(True)
        End If
        Dim NewTemp As Boolean = NewTemperatureAvailable()
        While Not NewTemp
            Thread.Sleep(10000) '10ms sleep
            NewTemp = NewTemperatureAvailable()
        End While
        Dim Temp As Integer = GetTemp()
        Return Temp
    End Function
    
    //accelerometer functions
    
    Public Function GetStatus() As Byte
        'ZYXOR X-, Y- and Z-axis data overrun. Default value: 0
        '(0: no overrun has occurred; 1: a new set of data has overwritten the previous set)
        'ZOR Z-axis data overrun. Default value: 0
        'YOR Y-axis data overrun. Default value: 0
        'XOR X-axis data overrun. Default value: 0
        'ZYXDA X-, Y- and Z-axis new data available. Default value: 0
        '(0: a new set of data is not yet available; 1: a new set of data is available)
        'ZDA Z-axis new data available. Default value: 0
        'YDA Y-axis new data available. Default value: 0
        'XDA Y-axis new data available. Default value: 0
        Return Read(STATUS)
    End Function
    
    Public Function NewDataAvailable() As Boolean
        'returns if new x,y or z data is available (or data overrun)
        'ZYXOR X-, Y- and Z-axis data overrun. Default value: 0
        '(0: no overrun has occurred; 1: a new set of data has overwritten the previous set)
        'ZOR Z-axis data overrun. Default value: 0
        'YOR Y-axis data overrun. Default value: 0
        'XOR X-axis data overrun. Default value: 0
        'ZYXDA X-, Y- and Z-axis new data available. Default value: 0
        '(0: a new set of data is not yet available; 1: a new set of data is available)
        'ZDA Z-axis new data available. Default value: 0
        'YDA Y-axis new data available. Default value: 0
        'XDA Y-axis new data available. Default value: 0
        Return (Read(STATUS) & (ZYXDA | ZYXOR)).ToBoolean
    End Function
    
    Public Sub EnableAxis(axis As Byte)
        //x=0,y=1,z=3 to enable axis
        Write(CTRL_REG1, (Read(CTRL_REG1) & ~(X_AXIS | Y_AXIS | Z_AXIS)) | axis) // write bits 0,1,2
    End Sub
    
    Public Function GetAxisEnabled() As Byte
        Return (Read(CTRL_REG1) & (X_AXIS | Y_AXIS | Z_AXIS))
    End Function
    
    Public Sub SetSleepToWakeThreshold(threshold As Float)
        'A 7-bit unsigned number, with g/LSB. dependant on range setting and mode (values are for LOW_POWER_MODE)
        '1 LSb = 16 mg @ FS = 2 g
        '1 LSb = 32 mg @ FS = 4 g
        '1 LSb = 62 mg @ FS = 8 g
        '1 LSb = 186 mg @ FS = 16 g
        'below threshold, accelerometer operates at 10Hz/LOW_POWER mode, if threshold is exceeded for
        'duration (see below), accelerometer resumes the set ODR/mode
        Dim thresholdByte As Byte = 0
        If threshold <= 2.0 Then
            SetScale(SCALE_2G)
            thresholdByte = map_range(threshold, 0, 2.0, 0, 0x7f)
        ElseIf threshold <= 4.0 Then
            SetScale(SCALE_4G)
            thresholdByte = map_range(threshold, 0, 4.0, 0, 0x7f)
        ElseIf threshold <= 8.0 Then
            SetScale(SCALE_8G)
            thresholdByte = map_range(threshold, 0, 8.0, 0, 0x7f)
        ElseIf threshold <= 16.0 Then
            SetScale(SCALE_16G)
            thresholdByte = map_range(threshold, 0, 16.0, 0, 0x7f)
        End If
        If thresholdByte <= 0x7f Then
            Write(ACT_THS, thresholdByte)
        End If
    End Sub
    
    Public Sub SetSleepToWakeDuration(duration As Float)
        'An 8-bit unsigned number, with duration dependant on data rate
        'Sleep-to-wake, return-to-sleep duration in ms
        '1 LSb = (8*1[LSb]+1)/ODR
        'value of 0 @ 50Hz = 1/50 = 20 ms, value of 1 = (8*1 + 1)/50 = 9/50 = 180ms 
        'our equation becomes duration = ((8*X)+1)*msPerCount, solving for X
        'X = ((duration/msPerCount) - 1)/8
        'so if duration is 5000ms, @ 50Hz = ((5000/50)-1)/8 = 249/8 = 31(.125)
        'below threshold (see above), accelerometer operates at 10Hz/LOW_POWER mode, if threshold
        'is exceeded, accelerometer resumes the set ODR/mode for duration ms
        Dim msPerCount As Float = GetmsFromDataRate()
        Dim count As Byte = (((duration / msPerCount) - 1) / 8).ToByte
        If count > 0xff Then
            'need to reduce frequency
            count = 0xff
        End If
        Write(ACT_DUR, count)
    End Sub
    
    Public Sub SetSleepMode(threshold As Float, duration As Float)
        'convenience function
        SetSleepToWakeThreshold(threshold)
        SetSleepToWakeDuration(duration)
    End Sub
    
    Public Sub SetMode(mode As Byte)
        'Set Operating Mode
        'modes are high-resolution mode, normal mode and low-power mode.
        '                                          LP( ctlreg1[3] HR ctlreg4[3]
        'Low-power mode (8-bit data output)        1              0 
        'Normal mode    (10-bit data output)       0              0
        'High-resolution mode (12-bit data output) 0              1
        ' note, minnimum time to transition modes is 1/ODR, for High-resolution this is 7/ODR
        
        If mode = LOW_POWER_MODE Then
            'Set Low Power 8 bit mode (LPEN_BIT = 1, HR_BIT = 0)
            Write(CTRL_REG1, (Read(CTRL_REG1) & ~LPEN_BIT) | LPEN_BIT) // clear bit 3, set LPmode
            Write(CTRL_REG4, (Read(CTRL_REG4) & ~HR_BIT)) // clear bit 3, disable HR mode
        ElseIf mode = NORMAL_MODE Then
            'Set Normal 10 bit mode (LPEN_BIT = 0, HR_BIT = 0)
            Write(CTRL_REG1, (Read(CTRL_REG1) & ~LPEN_BIT)) // clear bit 3, disable LPmode
            Write(CTRL_REG4, (Read(CTRL_REG4) & ~HR_BIT)) // clear bit 3, disable HR mode
        ElseIf mode = HIGH_RESOLUTION_MODE Then
            'Set High Resolution 12 bit mode (LPEN_BIT = 0, HR_BIT = 1)
            Write(CTRL_REG1, (Read(CTRL_REG1) & ~LPEN_BIT)) // clear bit 3, disable LPmode
            Write(CTRL_REG4, (Read(CTRL_REG4) & ~HR_BIT) | HR_BIT) // clear bit 3, enable HR mode
        End If
    End Sub
    
    Public Function GetMode() As Byte
        'Get Operating Mode
        'modes are high-resolution mode, normal mode and low-power mode.
        '                                          LP( ctlreg1[3] HR ctlreg4[3]
        'Low-power mode (8-bit data output)        1              0 
        'Normal mode    (10-bit data output)       0              0
        'High-resolution mode (12-bit data output) 0              1
        
        Dim LPbit As Boolean = (Read(CTRL_REG1) & LPEN_BIT).ToBoolean// read bit 3, LPmode
        Dim HRbit As Boolean = (Read(CTRL_REG4) & HR_BIT).ToBoolean// read bit 3,  HR mode
        
        If LPbit Then
            Return LOW_POWER_MODE
        End If
        
        If HRbit Then
            Return HIGH_RESOLUTION_MODE
        End If
        // otherwise normal mode
        Return NORMAL_MODE
    End Function
    
    Public Function GetResolution() As Byte
        'Get number of bits of resolution for the current mode
        'modes are high-resolution mode, normal mode and low-power mode.
        '                                          LP( ctlreg1[3] HR ctlreg4[3]
        'Low-power mode (8-bit data output)        1              0 
        'Normal mode    (10-bit data output)       0              0
        'High-resolution mode (12-bit data output) 0              1
        
        Dim mode As Byte = GetMode()
        Dim HRbit As Boolean = (Read(CTRL_REG4) & HR_BIT).ToBoolean// read bit 3,  HR mode
        
        Select mode
            Case LOW_POWER_MODE
                Return 8
            Case NORMAL_MODE
                Return 10
            Case HIGH_RESOLUTION_MODE
                Return 12
            Case Else
                Return 1
        End Select
    End Function
    
    Public Sub SetDataRate(rate As Byte)
        'Set Data Rate, bits 4,5,6,7
        'Data rate selection. Default value: 0000
        '(0000: power-down mode; others: refer to Table 27)
        Write(CTRL_REG1, (Read(CTRL_REG1) & ~DATA_RATE_MASK) | (rate << 4)) 
    End Sub
    
    Public Function GetDataRate() As Byte
        'Get Data Rate, bits 4,5,6,7
        'Data rate selection. Default value: 0000
        '(0000: power-down mode; others: refer to Table 27)
        Return ((Read(CTRL_REG1) & DATA_RATE_MASK) >> 4)
    End Function
    
    
    Public Function GetmsFromDataRate() As Float
        'Get Data Rate, bits 4,5,6,7
        'return as ms
        Dim ms As Float = 0.0
        Dim mode As Byte = GetMode()
        Dim dataRate As Byte = GetDataRate()
        Select dataRate
            Case DATA_RATE_POWER_DOWN 'no data rate, accel is off!
                ms = 10000.0
            Case DATA_RATE_1HZ
                ms = 1000.0
            Case DATA_RATE_10HZ
                ms = 100.0
            Case DATA_RATE_25HZ
                ms = 40.0
            Case DATA_RATE_50HZ
                ms = 20.0
            Case DATA_RATE_100HZ
                ms = 10.0
            Case DATA_RATE_200HZ
                ms = 5.0
            Case DATA_RATE_400HZ
                ms = 2.5
            Case DATA_RATE_1620HZ_LP 'low power mode only
                ms = 0.617
            Case DATA_RATE_1344HZ 'in low power mode this is 5376 Hz
                If mode = LOW_POWER_MODE Then
                    ms = 0.186
                Else
                    ms = 0.744
                End If
            Case Else
                ms = 20.0
        End Select
        Return ms
    End Function
    
    Public Sub SetScale(scale As Byte)
        'Set Scale, bits 4,5
        'Full-scale selection. Default value: 00
        '(00: ±2g; 01: ±4g; 10: ±8g; 11: ±16g)
        Write(CTRL_REG4, (Read(CTRL_REG4) & ~SCALE_MASK) | (scale << 4)) 
    End Sub
    
    Public Function GetScale() As Byte
        'Get Scale, bits 4,5
        'Full-scale selection. Default value: 00
        '(00: ±2g; 01: ±4g; 10: ±8g; 11: ±16g)
        Return ((Read(CTRL_REG4) & SCALE_MASK) >> 4)
    End Function
    
    Public Function GetScaleAsFloat() As Float
        'Get Scale as G value
        Dim scale As Byte = GetScale()
        Dim Result As Float
        If (scale & SCALE_2G) = SCALE_2G Then
            Result = 2.0
        ElseIf (scale & SCALE_4G) = SCALE_4G Then
            Result = 4.0
        ElseIf (scale & SCALE_8G) = SCALE_8G Then
            Result = 8.0
        ElseIf (scale & SCALE_16G) = SCALE_16G Then
            Result = 16.0
        End If
        Return Result
    End Function
    
    Public Sub SetBlockData(block As Byte)
        'BDU Block data update. Default value: 0
        '(0: continuous update; 1: output registers not updated until MSB and LSB
        'have been read)
        Write(CTRL_REG4, (Read(CTRL_REG4) & ~BDU_BIT) | block) 
    End Sub
    
    Public Function GetBlockData() As Byte
        'Get Scale, bits 4,5
        'Full-scale selection. Default value: 00
        '(00: ±2g; 01: ±4g; 10: ±8g; 11: ±16g)
        Return (Read(CTRL_REG4) & BDU_BIT)
    End Function
    
    Public Sub SetEndian(endian As Byte)
        'Big/Little Endian data selection. Default value: 0
        '(0: data LSb at lower address; 1: data MSb at lower address)
        'The BLE function can be activated only in high-resolution mode
        Write(CTRL_REG4, (Read(CTRL_REG4) & ~BLE_BIT) | endian)
    End Sub
    
    Public Function GetEndian() As Byte
        'Big/Little Endian data selection. Default value: 0
        '(0: data LSb at lower address; 1: data MSb at lower address)
        'The BLE function can be activated only in high-resolution mode
        Return (Read(CTRL_REG4) & BLE_BIT)
    End Function
    
    Public Sub SetIntLogic(active As Boolean)
        'set interupts as active high or low
        'True = LOW (normal setting)
        If active Then
            'Set interrupt as active low
            SetCTL6Bits(GetCTL6Bits() | H_LACTIVE)
        Else
            'Set interrupt as active high (default)
            SetCTL6Bits(GetCTL6Bits() & ~H_LACTIVE)
        End If
    End Sub
    
    Public Sub SetIntPinConfig(interrupt As Byte, IntPin As Byte, Latch As Boolean)
        'set interrupt to pin configuration, latched or not.
        'this setting is cumulative, ie it adds on to previous confiurations.
        If interrupt = 1 Then
            If IntPin = 1 Then
                'Add AOI1 interrupt on INT1 Pin (INT is the pin AOI is the interrupt)
                SetPin1Interrupts(GetPin1Interrupts() | INT1_AOI1_BIT)
            Else
                'Add AOI1 interrupt on INT2 Pin (I is the pin INT is the Interrupt)
                SetCTL6Bits(GetCTL6Bits() | I2_INT1)
            End If
            If Latch Then
                'Add Latch Interrupt (Interrupt cleared by reading INT1_SRC register)
                SetCTL5Bits(GetCTL5Bits() | LIR_INT1)
            End If
        Else
            If IntPin = 1 Then
                'Add AOI2 interrupt on INT1 Pin
                SetPin1Interrupts(GetPin1Interrupts() | INT1_AOI2_BIT)
            Else
                'Add AOI2 interrupt on INT2 Pin
                SetCTL6Bits(GetCTL6Bits() | I2_INT2)
            End If
            If Latch Then
                'Add Latch Interrupt (Interrupt cleared by reading INT2_SRC register)
                SetCTL5Bits(GetCTL5Bits() | LIR_INT2)
            End If
        End If
    End Sub
    
    Public Sub SetFilterMode(mode As Byte)
        'Set High Pass Filter mode, bits 6,7
        'High-pass filter mode selection. Default value: 00
        'bit 7, 6
        '0 0 Normal mode (reset by reading REFERENCE/DATACAPTURE (26h) register)
        '0 1 Reference signal for filtering
        '1 0 Normal mode
        '1 1 Autoreset on interrupt event
        Write(CTRL_REG2, (Read(CTRL_REG2) & ~HP_FILTER_MODE_MASK) | mode << 6) 
    End Sub
    
    Public Function GetFilterMode() As Byte
        'Get High Pass Filter mode, bits 6,7
        'High-pass filter mode selection. Default value: 00
        'bit 7, 6
        '0 0 Normal mode (reset by reading REFERENCE/DATACAPTURE (26h) register)
        '0 1 Reference signal for filtering
        '1 0 Normal mode
        '1 1 Autoreset on interrupt event
        Return (Read(CTRL_REG2) & HP_FILTER_MODE_MASK >> 6) 
    End Function
    
    Public Sub SetFilterRange(range As Byte)
        'Set High Pass Filter Frequency Cut Off, bits 4,5
        'High-pass filter Range selection. Default value: 00
        'Depends on ODR frequency setting (see table in app note)
        'bit 4, 5
        '0 0 High
        '0 1 Medium
        '1 0 Low
        '1 1 Very Low
        Write(CTRL_REG2, (Read(CTRL_REG2) & ~HP_CUTOFF_MASK) | range << 5) 
    End Sub
    
    Public Function GetFilterRange() As Byte
        'Get High Pass Filter Frequency Cut Off, bits 4,5
        'High-pass filter Range selection. Default value: 00
        'Depends on ODR frequency setting (see table in app note)
        'bit 4, 5
        '0 0 High
        '0 1 Medium
        '1 0 Low
        '1 1 Very Low
        Return (Read(CTRL_REG2) & HP_CUTOFF_MASK >> 5) 
    End Function
    
    Public Sub SetFilterBypass(mode As Boolean)
        'Set internal filter NOT bypassed, bit3
        'so TRUE is unfiltered data (default), FALSE is data is filtered.
        'Filtered data selection. Default value: 0
        '(0: internal filter bypassed; 1: data from internal filter sent to output register and FIFO)
        If mode Then
            Write(CTRL_REG2, (Read(CTRL_REG2) & ~HP_FILTER_BYPASS_BIT))
        Else
            Write(CTRL_REG2, (Read(CTRL_REG2) & ~HP_FILTER_BYPASS_BIT) | HP_FILTER_BYPASS_BIT)
        End If 
    End Sub
    
    Public Function GetFilterBypass() As Boolean
        'Get internal filter bypassed, bit3
        'Filtered data selection. Default value: 0
        '(0: internal filter bypassed; 1: data from internal filter sent to output register and FIFO)
        Return (Read(CTRL_REG2) & HP_FILTER_BYPASS_BIT).ToBoolean()
    End Function
    
    Public Sub SetFilterClick(mode As Boolean)
        'Set High-pass filter enable for CLICK function. bit 2
        '(0: filter bypassed; 1: filter enabled)
        If mode Then
            Write(CTRL_REG2, (Read(CTRL_REG2) & ~HP_INT_CLICK_BIT) | HP_INT_CLICK_BIT)
        Else
            Write(CTRL_REG2, (Read(CTRL_REG2) & ~HP_INT_CLICK_BIT))
        End If
    End Sub
    
    Public Function GetFilterClick() As Boolean
        'Get High-pass filter enable for CLICK function. bit 2
        '(0: filter bypassed; 1: filter enabled)
        Return (Read(CTRL_REG2) & HP_INT_CLICK_BIT).ToBoolean()
    End Function
    
    Public Sub SetFilterAOI1(mode As Boolean)
        'Set High-pass filter enable for AOI function on Interrupt 1 (bit 0)
        '(0: filter bypassed; 1: filter enabled)
        If mode Then
            Write(CTRL_REG2, (Read(CTRL_REG2) & ~HP_INT_AOI1_BIT) | HP_INT_AOI1_BIT)
        Else
            Write(CTRL_REG2, (Read(CTRL_REG2) & ~HP_INT_AOI1_BIT))
        End If
    End Sub
    
    Public Function GetFilterAOI1() As Boolean
        'Get High-pass filter enable for AOI function on Interrupt 1 (bit 0)
        '(0: filter bypassed; 1: filter enabled)
        Return (Read(CTRL_REG2) & HP_INT_AOI1_BIT).ToBoolean()
    End Function
    
    Public Sub SetFilterAOI2(mode As Boolean)
        'Set High-pass filter enable for AOI function on Interrupt 2 (bit 1)
        '(0: filter bypassed; 1: filter enabled)
        If mode Then
            Write(CTRL_REG2, (Read(CTRL_REG2) & ~HP_INT_AOI2_BIT) | HP_INT_AOI2_BIT)
        Else
            Write(CTRL_REG2, (Read(CTRL_REG2) & ~HP_INT_AOI2_BIT))
        End If
    End Sub
    
    Public Function GetFilterAOI2() As Boolean
        'Get High-pass filter enable for AOI function on Interrupt 2 (bit 1)
        '(0: filter bypassed; 1: filter enabled)
        Return (Read(CTRL_REG2) & HP_INT_AOI2_BIT).ToBoolean()
    End Function 
    
    Public Sub SetPin1Interrupts(mode As Byte)
        'Set pin 1 Enable bits  bits 1,2,3,4,5,6,7 (bit 0 not used)
        '(0: disable; 1: enable)
        'I1_CLICK CLICK interrupt on INT1 pin. Default value 0. bit 7
        'I1_AOI1 AOI1 interrupt on INT1 pin. Default value 0. bit 6
        'I1_AOI2 AOI2 interrupt on INT1 pin. Default value 0. bit 5
        'I1_DRDY1 DRDY1 interrupt on INT1 pin. Default value 0. bit 4
        'I1_DRDY2 DRDY2 interrupt on INT1 pin. Default value 0. bit 3
        'I1_WTM FIFO watermark interrupt on INT1 pin. Default value 0. bit 2
        'I1_OVERRUN FIFO overrun interrupt on INT1 pin. Default value 0. bit 1
        Write(CTRL_REG3, (Read(CTRL_REG3) & ~INT1_ENABLE_MASK) | mode) 
    End Sub
    
    Public Function GetPin1Interrupts() As Byte
        'Get pin 1 Enable bits  bits 1,2,3,4,5,6,7
        Return Read(CTRL_REG3)  
    End Function
    
    Public Sub SetCTL5Bits(mode As Byte)
        'Set latching Enable bits  bits 0,1,2,3,6,7 (bits 4,5 not used)
        '(0: disable; 1: enable)
        'BOOT Reboot memory content. Default value: 0   bit 7
        '(0: normal mode; 1: reboot memory content)
        'FIFO_EN FIFO enable. Default value: 0 bit 6
        'LIR_INT1 Latch interrupt request on INT1_SRC (31h), with INT1_SRC (31h) register cleared
        'by reading INT1_SRC (31h) itself. Default value: 0. bit 3
        '(0: interrupt request not latched; 1: interrupt request latched)
        'D4D_INT1 4D enable: 4D detection is enabled on INT1 pin when 6D bit on INT1_CFG (30h) is
        'set to 1. bit 2
        'LIR_INT2 Latch interrupt request on INT2_SRC (35h) register, with INT2_SRC (35h) register
        'cleared by reading INT2_SRC (35h) itself. Default value: 0.
        '(0: interrupt request not latched; 1: interrupt request latched) bit 1
        'D4D_INT2 4D enable: 4D detection is enabled on INT2 pin when 6D bit on INT2_CFG (34h) is
        'set to 1. bit 0
        Write(CTRL_REG5, (Read(CTRL_REG5) & ~CTL5_MASK) | mode) 
    End Sub
    
    Public Function GetCTL5Bits() As Byte
        'Get latching Enable bits  bits 1,2,3,4,5,6,7
        'see above
        Return Read(CTRL_REG5)
    End Function
    
    Public Sub SetCTL6Bits(mode As Byte)
        'Set pin 2 Enable bits (and general interupt active level)  bits 1,3,4,5,6,7 (bits 0,2 not used)
        '(0: disabled; 1: enabled)
        'I2_CLICKen Click interrupt on INT2 pin. Default value: 0 bit 7
        'I2_INT1 Interrupt 1 function enable on INT2 pin. Default value: 0 bit 6
        'I2_INT2 Interrupt 2 function enable on INT2 pin. Default value: 0 bit 5
        'BOOT_I2 Boot on INT2 pin enable. Default value: 0 bit 4
        'P2_ACT Activity interrupt enable on INT2 pin. Default value: 0. bit 3
        'H_LACTIVE interrupt active. Default value: 0. bit 1
        '(0: interrupt active-high; 1: interrupt active-low)
        Write(CTRL_REG6, (Read(CTRL_REG6) & ~CTL6_MASK) | mode) 
    End Sub
    
    Public Function GetCTL6Bits() As Byte
        'Get pin 2 Enable bits (and misc others)  bits 1,3,4,5,6,7 (bits 0,2 not used)
        'see above
        Return Read(CTRL_REG6)
    End Function
    
    Public Sub SetINT1Threshold(threshold As Float)
        'A 7-bit unsigned number, with g/LSB. dependant on range setting and mode (values are for LOW_POWER_MODE)
        '1 LSb = 16 mg @ FS = 2 g
        '1 LSb = 32 mg @ FS = 4 g
        '1 LSb = 62 mg @ FS = 8 g
        '1 LSb = 186 mg @ FS = 16 g
        Dim thresholdByte As Byte = 0
        If threshold <= 2.0 Then
            SetScale(SCALE_2G)
            thresholdByte = map_range(threshold, 0, 2.0, 0, 0x7f)
        ElseIf threshold <= 4.0 Then
            SetScale(SCALE_4G)
            thresholdByte = map_range(threshold, 0, 4.0, 0, 0x7f)
        ElseIf threshold <= 8.0 Then
            SetScale(SCALE_8G)
            thresholdByte = map_range(threshold, 0, 8.0, 0, 0x7f)
        ElseIf threshold <= 16.0 Then
            SetScale(SCALE_16G)
            thresholdByte = map_range(threshold, 0, 16.0, 0, 0x7f)
        End If
        If thresholdByte <= 0x7f Then
            Write(INT1_THS, thresholdByte)
        End If
    End Sub
    
    Public Sub SetINT2Threshold(threshold As Float)
        'A 7-bit unsigned number, with g/LSB. dependant on range setting and mode (values are for LOW_POWER_MODE)
        '1 LSb = 16 mg @ FS = 2 g
        '1 LSb = 32 mg @ FS = 4 g
        '1 LSb = 62 mg @ FS = 8 g
        '1 LSb = 186 mg @ FS = 16 g
        Dim thresholdByte As Byte = 0
        If threshold <= 2.0 Then
            SetScale(SCALE_2G)
            thresholdByte = map_range(threshold, 0, 2.0, 0, 0x7f)
        ElseIf threshold <= 4.0 Then
            SetScale(SCALE_4G)
            thresholdByte = map_range(threshold, 0, 4.0, 0, 0x7f)
        ElseIf threshold <= 8.0 Then
            SetScale(SCALE_8G)
            thresholdByte = map_range(threshold, 0, 8.0, 0, 0x7f)
        ElseIf threshold <= 16.0 Then
            SetScale(SCALE_16G)
            thresholdByte = map_range(threshold, 0, 16.0, 0, 0x7f)
        End If
        If thresholdByte <= 0x7f Then
            Write(INT2_THS, thresholdByte)
        End If
    End Sub
    
    Public Sub SetINT1Duration(duration As Float)
        'A 7-bit unsigned number, with duration dependant on data rate
        'Duration value. Default value: 000 0000
        '1 LSb = 1/ODR
        'Set Duration in ms (if set to 0, causes interrupt immediately, once threshold exceeded)
        'The duration in ms depends on the frequency, ie 50 Hz = 20ms per count, so 100ms = 5 counts
        Dim msPerCount As Float = GetmsFromDataRate()
        Dim count As Byte = (duration / msPerCount).ToByte
        If count > 0x7f Then
            'need to reduce frequency
            count = 0x7f
        End If
        Write(INT1_DURATION, count)
    End Sub
    
    Public Sub SetINT2Duration(duration As Float)
        'A 7-bit unsigned number, with duration dependant on data rate
        'Duration value. Default value: 000 0000
        '1 LSb = 1/ODR
        'Set Duration in ms (if set to 0, causes interrupt immediately, once threshold exceeded)
        'The duration in ms depends on the frequency, ie 50 Hz = 20ms per count, so 100ms = 5 counts
        Dim msPerCount As Float = GetmsFromDataRate()
        Dim count As Byte = (duration / msPerCount).ToByte
        If count > 0x7f Then
            'need to reduce frequency
            count = 0x7f
        End If
        Write(INT2_DURATION, count)
    End Sub
    
    Public Sub SetINT1Active(active As Boolean)
        'only use this to enable/disable INT1 after it has been configured!
        If gint1cfg = UNDEFINED Then
            Return
        End If
        If active Then
            SetINT1ActiveInterrupt(gint1cfg)
        Else
            gint1cfg = GetINT1Configuration()
            SetINT1ActiveInterrupt(0x00)
        End If
    End Sub
    
    Public Sub SetINT2Active(active As Boolean)
        'only use this to enable/disable INT2 after it has been configured!
        If gint2cfg = UNDEFINED Then
            Return
        End If
        If active Then
            SetINT2ActiveInterrupt(gint2cfg)
        Else
            gint2cfg = GetINT2Configuration()
            SetINT2ActiveInterrupt(0x00)
        End If
    End Sub
    
    Public Sub SetINT1ActiveInterrupt(interrupt As Byte)
        'AOI And/Or combination of interrupt events. Default value: 0. Refer to Table 51 bit 7
        '6D 6-direction detection function enabled. Default value: 0. Refer to Table 51 bit 6
        'AOI 6D Interrupt mode
        ' 0  0 OR combination of interrupt events
        ' 0  1 6-direction movement recognition
        ' 1  0 AND combination of interrupt events
        ' 1  1 6-direction position recognition
        'Default value: 0 (0: disable interrupt request;1: enable interrupt request) 
        'ZHIE/ZUPE Enable interrupt generation on Z high event or on direction recognition. bit 5
        'ZLIE/ZDOWNE Enable interrupt generation on Z low event or on direction recognition. bit 4
        'YHIE/YUPE Enable interrupt generation on Y high event or on direction recognition. bit 3
        'YLIE/YDOWNE Enable interrupt generation on Y low event or on direction recognition. bit 2
        'XHIE/XUPE Enable interrupt generation on X high event or on direction recognition. bit 1
        'XLIE/XDOWNE Enable interrupt generation on X low event or on direction recognition. bit 0
        Write(INT1_CFG, interrupt)
    End Sub
    
    Public Function GetINT1Configuration() As Byte
        'AOI And/Or combination of interrupt events. Default value: 0. Refer to Table 51 bit 7
        '6D 6-direction detection function enabled. Default value: 0. Refer to Table 51 bit 6
        'AOI 6D Interrupt mode
        ' 0  0 OR combination of interrupt events
        ' 0  1 6-direction movement recognition
        ' 1  0 AND combination of interrupt events
        ' 1  1 6-direction position recognition
        'Default value: 0 (0: disable interrupt request;1: enable interrupt request) 
        'ZHIE/ZUPE Enable interrupt generation on Z high event or on direction recognition. bit 5
        'ZLIE/ZDOWNE Enable interrupt generation on Z low event or on direction recognition. bit 4
        'YHIE/YUPE Enable interrupt generation on Y high event or on direction recognition. bit 3
        'YLIE/YDOWNE Enable interrupt generation on Y low event or on direction recognition. bit 2
        'XHIE/XUPE Enable interrupt generation on X high event or on direction recognition. bit 1
        'XLIE/XDOWNE Enable interrupt generation on X low event or on direction recognition. bit 0
        Return Read(INT1_CFG)
    End Function
    
    Public Function GetINT1ActiveInterrupt() As Byte
        'bit 7 not used
        'IA Interrupt active. Default value: 0 bit 6
        '(0: no interrupt has been generated; 1: one or more interrupts have been generated)
        'ZH Z high. Default value: 0 bit 5
        '(0: no interrupt, 1: Z high event has occurred)
        'ZL Z low. Default value: 0 bit 4
        '(0: no interrupt; 1: Z low event has occurred)
        'YH Y high. Default value: 0 bit 3
        '(0: no interrupt, 1: Y high event has occurred)
        'YL Y low. Default value: 0 bit 2
        '(0: no interrupt, 1: Y low event has occurred)
        'XH X high. Default value: 0 bit 1
        '(0: no interrupt, 1: X high event has occurred)
        'XL X low. Default value: 0 bit 0
        '(0: no interrupt, 1: X low event has occurred)
        Return Read(INT1_SRC)
    End Function
    
    Public Function GetIntSource(intSource As Byte, configReg As Byte) As ListOfString
        Dim result As ListOfString = New ListOfString
        
        If (intSource & INT_ACTIVE) = INT_ACTIVE Then 'only report if active
            intSource = intSource & configReg 'only report on enabled interrupts
            If (intSource & INT_SRC_ZH) = INT_SRC_ZH Then
                result.Add("z_high")
            End If
            If (intSource & INT_SRC_ZL) = INT_SRC_ZL Then
                result.Add("z_low")
            End If
            If (intSource & INT_SRC_YH) = INT_SRC_YH Then
                result.Add("y_high")
            End If
            If (intSource & INT_SRC_YL) = INT_SRC_YL Then
                result.Add("y_low")
            End If
            If (intSource & INT_SRC_XH) = INT_SRC_XH Then
                result.Add("x_high")
            End If
            If (intSource & INT_SRC_XL) = INT_SRC_XL Then
                result.Add("x_low")
            End If
            If (intSource & (INT_SRC_XL | INT_SRC_YL | INT_SRC_ZL)) = (INT_SRC_XL | INT_SRC_YL | INT_SRC_ZL) Then
                result.Add("freefall")
            End If
        End If
        
        Return result
    End Function // GetIntSource
    
    Public Function GetInt1Source() As ListOfString
        'get active interrupts on INT1
        Dim result As ListOfString = New ListOfString
        If (GetINT1Configuration() & INT_6D_BIT) = INT_6D_BIT Then 'orientation mode
            result.Add(GetInt1Orientation())
        Else
            result = GetIntSource(GetINT1ActiveInterrupt(), GetINT1Configuration())
        End If
        Return result
    End Function // GetInt1Source
    
    Public Function GetInt2Source() As ListOfString
        'get active interrupts on INT2
        Dim result As ListOfString = New ListOfString
        If (GetINT2Configuration() & INT_6D_BIT) = INT_6D_BIT Then 'orientation mode
            result.Add(GetInt2Orientation())
        Else
            result = GetIntSource(GetINT2ActiveInterrupt(), GetINT2Configuration())
        End If
        Return result
    End Function // GetInt2Source
    
    Public Function insertValuesintoJson(jdata As Json, accelValues As ListOfFloat) As Json
        'insert values into each axis in json
        Dim jtmp As Json = New Json
        If accelValues.Count= 3 And jdata.Count> 0 Then
            Dim tmpstr As String
            Dim jval As JProperty
            For item_number As Integer = 0 To jdata.Count() - 1
                jval = jdata.Item(item_number)
                tmpstr = jval.Name()
                If tmpstr.Contains("x") Or tmpstr.Contains("top") Or tmpstr.Contains("bottom") Then
                    jtmp.Add(tmpstr, accelValues(0))
                ElseIf tmpstr.Contains("y") Or tmpstr.Contains("left") Or tmpstr.Contains("right") Then
                    jtmp.Add(tmpstr, accelValues(1))
                ElseIf tmpstr.Contains("z") Or tmpstr.Contains("up") Or tmpstr.Contains("down") Then
                    jtmp.Add(tmpstr, accelValues(2))
                Else
                    jtmp.Add(jval)
                End If
            Next
        End If
        If jtmp.Count> 0 Then
            Return jtmp
        End If
        Return jdata
    End Function
    
    Public Function GetValuesSummaryasJson(accelValues As ListOfFloat) As Json
        'get summary of x,y,z values as json
        Dim jaccelValues As Json = New Json
        If accelValues.Count= 3 Then
            jaccelValues.Add("x", accelValues(0))
            jaccelValues.Add("y", accelValues(1))
            jaccelValues.Add("z", accelValues(2))
        End If
        Return jaccelValues
    End Function
    
    Public Function GetInt1SourceAsJson() As Json
        'get json with Boolean jValue
        Return GetInt1SourceAsJson(J_NONE)
    End Function
    
    Public Function GetInt2SourceAsJson() As Json
        'get json with Boolean jValue
        Return GetInt2SourceAsJson(J_NONE)
    End Function
    
    Public Function GetInt1SourceAsJson(options As Byte) As Json
        'get active interrupts on INT1 as json
        Return GetIntSourceAsJson(options, GetInt1Source())
    End Function // GetInt1SourceAsJson
    
    Public Function GetInt2SourceAsJson(options As Byte) As Json
        'get active interrupts on INT2 as json
        Return GetIntSourceAsJson(options, GetInt2Source())
    End Function // GetInt2SourceAsJson
    
    Public Function GetIntSourceAsJson(options As Byte, source As ListOfString) As Json
        'get active interrupts as json
        'options are J_NONE (no values, just Boolean jvalue)
        '            J_VALUES (acceleration value replaces boolean)
        '            J_SUMMARY (summary of x,y,z values is appended to json)
        'you can combine the two options (J_VALUES | J_SUMMARY) to get variants
        Dim result As ListOfString = source
        Dim jResult As Json = New Json
        Dim accelValues As ListOfFloat
        
        If result.Count> 0 Then
            For Each item In result
                jResult.Add(item, True)
            Next
            
            If options > J_NONE Then
                accelValues = GetAccel()
            End If
            If (options & J_VALUES) = J_VALUES Then
                jResult = insertValuesintoJson(jResult, accelValues)
            End If
            If (options & J_SUMMARY) = J_SUMMARY Then
                jResult.Add("Values", GetValuesSummaryasJson(accelValues))
            End If
        End If
        Return jResult
    End Function // GetIntSourceAsJson
    
    Public Function GetIntSourceAsJsonValue(source As ListOfString) As ListOfJValue
        'get active interrupts as ListOfJValue
        Dim result As ListOfString = source
        Dim jResult As ListOfJValue = New ListOfJValue
        If result.Count> 0 Then
            For Each item In result
                Dim jitem As JValue = New JValue(item)
                jResult.Add(jitem)
            Next
        End If
        Return jResult
    End Function // GetIntSourceAsJson
    
    Public Function GetInt1SourceAsJsonValue() As ListOfJValue
        'get active interrupts on INT1 as ListOfJValue
        Return GetIntSourceAsJsonValue(GetInt1Source())
    End Function // GetInt1SourceAsJson
    
    Public Function GetInt2SourceAsJsonValue() As ListOfJValue
        'get active interrupts on INT2 as ListOfJValue
        Return GetIntSourceAsJsonValue(GetInt2Source())
    End Function // GetInt1SourceAsJson
    
    Public Function GetInt1Orientation() As String
        'special function to decode INT1_SOURCE in 6D/4D mode (only valid for that mode)
        Return GetIntOrientation(GetINT1ActiveInterrupt(), D4D_INT1)
    End Function // GetInt1Orientation
    
    Public Function GetInt2Orientation() As String
        'special function to decode INT2_SOURCE in 6D/4D mode (only valid for that mode)
        Return GetIntOrientation(GetINT2ActiveInterrupt(), D4D_INT2)
    End Function // GetInt2Orientation
    
    Public Function GetIntOrientation(intSource As Byte, interrupt As Byte) As String
        'special function to decode INTX_SRC in 6D/4D mode (only valid for that mode)
        Dim result As String
        Dim orientation As Byte = intSource & ~INT_ACTIVE
        
        Dim PLMode As Boolean = False 'is Portrate/landscape mode enabled for interrupt?
        If ((GetCTL5Bits() & interrupt) = interrupt) Then
            PLMode = True
        End If
        
        If (intSource & INT_ACTIVE) = INT_ACTIVE Then
            Select orientation
                Case INT_SRC_YL
                    If PLMode Then
                        result = "portrate_down"
                    Else
                        result = "left"
                    End If
                Case INT_SRC_YH
                    If PLMode Then
                        result = "portrate_up"
                    Else
                        result = "right"
                    End If
                Case INT_SRC_XL
                    If PLMode Then
                        result = "landscape_up"
                    Else
                        result = "top"
                    End If
                Case INT_SRC_XH
                    If PLMode Then
                        result = "landscape_down"
                    Else
                        result = "bottom"
                    End If
                Case INT_SRC_ZL
                    result = "down"
                Case INT_SRC_ZH
                    result = "up"
            End Select
        End If
        
        Return result
    End Function
    
    Public Sub SetINT2ActiveInterrupt(interrupt As Byte)
        'AOI And/Or combination of interrupt events. Default value: 0. Refer to Table 51 bit 7
        '6D 6-direction detection function enabled. Default value: 0. Refer to Table 51 bit 6
        'AOI 6D Interrupt mode
        ' 0  0 OR combination of interrupt events
        ' 0  1 6-direction movement recognition
        ' 1  0 AND combination of interrupt events
        ' 1  1 6-direction position recognition
        'Default value: 0 (0: disable interrupt request;1: enable interrupt request) 
        'ZHIE/ZUPE Enable interrupt generation on Z high event or on direction recognition. bit 5
        'ZLIE/ZDOWNE Enable interrupt generation on Z low event or on direction recognition. bit 4
        'YHIE/YUPE Enable interrupt generation on Y high event or on direction recognition. bit 3
        'YLIE/YDOWNE Enable interrupt generation on Y low event or on direction recognition. bit 2
        'XHIE/XUPE Enable interrupt generation on X high event or on direction recognition. bit 1
        'XLIE/XDOWNE Enable interrupt generation on X low event or on direction recognition. bit 0
        Write(INT2_CFG, interrupt)
    End Sub
    
    Public Function GetINT2Configuration() As Byte
        'AOI And/Or combination of interrupt events. Default value: 0. Refer to Table 51 bit 7
        '6D 6-direction detection function enabled. Default value: 0. Refer to Table 51 bit 6
        'AOI 6D Interrupt mode
        ' 0  0 OR combination of interrupt events
        ' 0  1 6-direction movement recognition
        ' 1  0 AND combination of interrupt events
        ' 1  1 6-direction position recognition
        'Default value: 0 (0: disable interrupt request;1: enable interrupt request) 
        'ZHIE/ZUPE Enable interrupt generation on Z high event or on direction recognition. bit 5
        'ZLIE/ZDOWNE Enable interrupt generation on Z low event or on direction recognition. bit 4
        'YHIE/YUPE Enable interrupt generation on Y high event or on direction recognition. bit 3
        'YLIE/YDOWNE Enable interrupt generation on Y low event or on direction recognition. bit 2
        'XHIE/XUPE Enable interrupt generation on X high event or on direction recognition. bit 1
        'XLIE/XDOWNE Enable interrupt generation on X low event or on direction recognition. bit 0
        Return Read(INT2_CFG)
    End Function
    
    Public Function GetINT2ActiveInterrupt() As Byte
        'bit 7 not used
        'IA Interrupt active. Default value: 0 bit 6
        '(0: no interrupt has been generated; 1: one or more interrupts have been generated)
        'ZH Z high. Default value: 0 bit 5
        '(0: no interrupt, 1: Z high event has occurred)
        'ZL Z low. Default value: 0 bit 4
        '(0: no interrupt; 1: Z low event has occurred)
        'YH Y high. Default value: 0 bit 3
        '(0: no interrupt, 1: Y high event has occurred)
        'YL Y low. Default value: 0 bit 2
        '(0: no interrupt, 1: Y low event has occurred)
        'XH X high. Default value: 0 bit 1
        '(0: no interrupt, 1: X high event has occurred)
        'XL X low. Default value: 0 bit 0
        '(0: no interrupt, 1: X low event has occurred)
        Return Read(INT2_SRC)
    End Function
    
    Public Sub SetRefDataCap(threshold As Float)
        'An 8-bit unsigned number, with g/LSB. dependant on range setting and mode (values are for LOW_POWER_MODE)
        '1 LSb = 16 mg @ FS = 2 g
        '1 LSb = 32 mg @ FS = 4 g
        '1 LSb = 62 mg @ FS = 8 g
        '1 LSb = 186 mg @ FS = 16 g
        'offset for interrupt threshold
        Dim thresholdByte As Byte = 0
        If threshold <= 2.0 Then
            SetScale(SCALE_2G)
            thresholdByte = map_range(threshold, 0, 2.0, 0, 0xff)
        ElseIf threshold <= 4.0 Then
            SetScale(SCALE_4G)
            thresholdByte = map_range(threshold, 0, 4.0, 0, 0xff)
        ElseIf threshold <= 8.0 Then
            SetScale(SCALE_8G)
            thresholdByte = map_range(threshold, 0, 8.0, 0, 0xff)
        ElseIf threshold <= 16.0 Then
            SetScale(SCALE_16G)
            thresholdByte = map_range(threshold, 0, 16.0, 0, 0xff)
        End If
        If thresholdByte <= 0xff Then
            Write(REF_DATA_CAP, thresholdByte)
        End If
    End Sub
    
    Public Function GetRefDataCap() As Byte
        'Reference value for interrupt generation. Default value: 0
        Return Read(REF_DATA_CAP)
    End Function
    
    Public Sub SetClickConfig(config As Byte)
        'bits 0,1,2,3,4,5
        'ZD Enable interrupt double-click on Z-axis. Default value: 0
        '(0: disable interrupt request; 1: enable interrupt request on measured accel. value
        'higher than preset threshold)
        'ZS Enable interrupt single-click on Z-axis. Default value: 0
        'YD Enable interrupt double-click on Y-axis. Default value: 0
        'YS Enable interrupt single-click on Y-axis. Default value: 0
        'XD Enable interrupt double-click on X-axis. Default value: 0
        'XS Enable interrupt single-click on X-axis. Default value: 0
        Write(CLICK_CFG, config)
    End Sub
    
    Public Function GetClickConfig() As Byte
        'ZD Enable interrupt double-click on Z-axis. Default value: 0
        '(0: disable interrupt request; 1: enable interrupt request on measured accel. value
        'higher than preset threshold)
        'ZS Enable interrupt single-click on Z-axis. Default value: 0
        'YD Enable interrupt double-click on Y-axis. Default value: 0
        'YS Enable interrupt single-click on Y-axis. Default value: 0
        'XD Enable interrupt double-click on X-axis. Default value: 0
        'XS Enable interrupt single-click on X-axis. Default value: 0
        Return Read(CLICK_CFG)
    End Function
    
    Public Sub SetClickLatch(mode As Boolean)
        'If the LIR_Click bit is not set, the interrupt is kept high for the duration of the latency window.
        'If the LIR_Click bit is set, the interrupt is kept high until the CLICK_SRC (39h) register is read.
        'This is missing from the datasheet, so its a guess as to whether it exists
        If mode Then
            Write(CLICK_THS, (Read(CLICK_THS) & ~LIR_Click) | LIR_Click)
        Else
            Write(CLICK_THS, (Read(CLICK_THS) & ~LIR_Click))
        End If
    End Sub
    
    Public Function GetClickLatch() As Boolean
        'If the LIR_Click bit is not set, the interrupt is kept high for the duration of the latency window.
        'If the LIR_Click bit is set, the interrupt is kept high until the CLICK_SRC (39h) register is read.
        'This is missing from the datasheet, so its a guess as to whether it exists
        Return (Read(CLICK_THS) & LIR_Click).ToBoolean()
    End Function
    
    Public Function GetClickSource() As Byte
        'IA Interrupt active. Default value: 0 bit 6
        '(0: no interrupt has been generated; 1: one or more interrupts have been generated)
        'DClick Double-click enable. Default value: 0 (0: double-click detection disabled,
        '1: double-click detection enabled) bit 5
        'SClick Single-click enable. Default value: 0 (0: single-click detection disabled, 1: single-click
        'detection enabled) bit 4
        'Sign Click sign. 0: positive detection, 1: negative detection bit 3
        'Z Z click detection. Default value: 0 bit 2
        '(0: no interrupt, 1: Z high event has occurred)
        'Y Y click detection. Default value: 0 bit 1
        'X X click detection. Default value: 0 bit 0
        Return Read(CLICK_SRC)
    End Function
    
    Public Function GetIntClickSourceAsJson() As Json
        'get active interrupts on Click as json
        Return GetIntClickSourceAsJson(J_NONE)
    End Function // GetIntClickSourceAsJson
    
    Public Function GetIntClickSourceAsJson(options As Byte) As Json
        'get active click interrupts as json
        Return GetIntSourceAsJson(options, GetIntClickSource())
    End Function // GetIntClickSourceAsJson
    
    Public Function GetIntClickSource() As ListOfString
        Dim intSource As Byte = GetClickSource()
        Dim result As ListOfString = New ListOfString
        
        If (intSource & CLICK_IA) = CLICK_IA Then 'only report if active
            If (intSource & DClick) = DClick Then
                result.Add("double")
                'ElseIf (intSource & SClick) = SClick Then
                '    result.Add("single")
            End If
            
            If (intSource & SClick) = SClick Then
                result.Add("single")
            End If
            
            If (intSource & CLICK_Z) = CLICK_Z Then
                If (intSource & Sign) = Sign Then
                    result.Add("z_axis_positive")
                Else
                    result.Add("z_axis_negative")
                End If
            End If
            If (intSource & CLICK_Y) = CLICK_Y Then
                If (intSource & Sign) = Sign Then
                    result.Add("y_axis_positive")
                Else
                    result.Add("y_axis_negative")
                End If
            End If
            If (intSource & CLICK_X) = CLICK_X Then
                If (intSource & Sign) = Sign Then
                    result.Add("x_axis_positive")
                Else
                    result.Add("x_axis_negative")
                End If
            End If
        End If
        
        Return result
    End Function // GetIntClickSource
    
    Public Sub SetClickThreshold(threshold As Float)
        'A 7-bit unsigned number, with g/LSB. dependant on range setting and mode (values are for LOW_POWER_MODE)
        '1 LSb = 16 mg @ FS = 2 g
        '1 LSb = 32 mg @ FS = 4 g
        '1 LSb = 62 mg @ FS = 8 g
        '1 LSb = 186 mg @ FS = 16 g
        Dim thresholdByte As Byte = 0
        If threshold <= 2.0 Then
            SetScale(SCALE_2G)
            thresholdByte = map_range(threshold, 0, 2.0, 0, 0x7f)
        ElseIf threshold <= 4.0 Then
            SetScale(SCALE_4G)
            thresholdByte = map_range(threshold, 0, 4.0, 0, 0x7f)
        ElseIf threshold <= 8.0 Then
            SetScale(SCALE_8G)
            thresholdByte = map_range(threshold, 0, 8.0, 0, 0x7f)
        ElseIf threshold <= 16.0 Then
            SetScale(SCALE_16G)
            thresholdByte = map_range(threshold, 0, 16.0, 0, 0x7f)
        End If
        If thresholdByte <= 0x7f Then
            Write(CLICK_THS, thresholdByte)
        End If
    End Sub
    
    Public Sub SetClickDuration(duration As Float)
        'A 7-bit unsigned number, with duration dependant on data rate
        'Duration value. Default value: 000 0000
        '1 LSb = 1/ODR
        'Set Duration in ms (if set to 0, causes interrupt immediately, once threshold exceeded)
        'The duration in ms depends on the frequency, ie 50 Hz = 20ms per count, so 100ms = 5 counts
        Dim msPerCount As Float = GetmsFromDataRate()
        Dim count As Byte = (duration / msPerCount).ToByte
        If count > 0x7f Then
            'need to reduce frequency
            count = 0x7f
        End If
        Write(TIME_LIMIT, count)
    End Sub
    
    Public Sub SetClickLatency(latency As Float)
        'An 8-bit unsigned number, with duration dependant on data rate
        'Duration value. Default value: 000 0000
        '1 LSb = 1/ODR
        'Set Duration in ms (if set to 0, causes interrupt immediately, once threshold exceeded)
        'The duration in ms depends on the frequency, ie 50 Hz = 20ms per count, so 100ms = 5 counts
        Dim msPerCount As Float = GetmsFromDataRate()
        Dim count As Byte = (latency / msPerCount).ToByte
        Write(TIME_LATENCY, count)
    End Sub
    
    Public Sub SetClickTimeWindow(window As Float)
        'An 8-bit unsigned number, with duration dependant on data rate
        'Duration value. Default value: 000 0000
        '1 LSb = 1/ODR
        'Set Duration in ms (if set to 0, causes interrupt immediately, once threshold exceeded)
        'The duration in ms depends on the frequency, ie 50 Hz = 20ms per count, so 100ms = 5 counts
        Dim msPerCount As Float = GetmsFromDataRate()
        Dim count As Byte = (window / msPerCount).ToByte
        Write(TIME_WINDOW, count)
    End Sub
    
    Public Function readAccelData() As ListOfShort
        'block read all 6 bytes, starting with X_L
        Dim rawData As ListOfByte = New ListOfByte // x/y/z accel register data stored here
        Dim destination As ListOfShort = New ListOfShort
        rawData = Read(OUT_X_L, 6) // Read the six raw data registers into data array
        If rawData <> Nothing Then
            destination.Add((rawData(0) << 8 | rawData(1)) >> 4)
            destination.Add((rawData(2) << 8 | rawData(3)) >> 4)
            destination.Add((rawData(4) << 8 | rawData(5)) >> 4)
        End If
        Return destination
    End Function
    
    Public Function readAccelDataBytes() As ListOfByte
        'block read all 6 bytes, starting with X_L
        Dim rawData As ListOfByte = New ListOfByte // x/y/z accel register data stored here
        rawData = Read(OUT_X_L, 6) // Read the six raw data registers into data array
        Return rawData
    End Function
    
    Public Function ReadConfiguration(items As Byte) As Json
        'reads all control registers and returns formatted json
        'select block with items = 0,1,2,3 or 4
        '0= general control registers
        '1= INT1 settings
        '2= INT2 settings
        '3= Click INT settings
        '4= Misc others
        
        Dim reg As String
        Dim jData As Json = New Json
        Select items
            Case 0
                'control registers (items = 1 or 2)
                reg = Read(CTRL_REG1).ToString("X2")
                jData.Add("CTRL_REG1", reg)
                reg = Read(CTRL_REG2).ToString("X2")
                jData.Add("CTRL_REG2", reg)
                reg = Read(CTRL_REG3).ToString("X2")
                jData.Add("CTRL_REG3", reg)
                reg = Read(CTRL_REG4).ToString("X2")
                jData.Add("CTRL_REG4", reg)
                reg = Read(CTRL_REG5).ToString("X2")
                jData.Add("CTRL_REG5", reg)
                reg = Read(CTRL_REG6).ToString("X2")
                jData.Add("CTRL_REG6", reg)
                reg = Read(STATUS).ToString("X2")
                jData.Add("STATUS", reg)
                
            Case 1
                'INT 1
                reg = Read(INT1_CFG).ToString("X2")
                jData.Add("INT1_CFG", reg)
                reg = Read(INT1_THS).ToString("X2")
                jData.Add("INT1_THS", reg)
                reg = Read(INT1_DURATION).ToString("X2")
                jData.Add("INT1_DURATION", reg)
            Case 2
                'INT 2
                reg = Read(INT2_CFG).ToString("X2")
                jData.Add("INT2_CFG", reg)
                reg = Read(INT2_THS).ToString("X2")
                jData.Add("INT2_THS", reg)
                reg = Read(INT2_DURATION).ToString("X2")
                jData.Add("INT2_DURATION", reg)
            Case 3
                'CLICK
                reg = Read(CLICK_CFG).ToString("X2")
                jData.Add("CLICK_CFG", reg)
                reg = Read(CLICK_THS).ToString("X2")
                jData.Add("CLICK_THS", reg)
                reg = Read(TIME_LIMIT).ToString("X2")
                jData.Add("TIME_LIMIT", reg)
                reg = Read(TIME_LATENCY).ToString("X2")
                jData.Add("TIME_LATENCY", reg)
                reg = Read(TIME_WINDOW).ToString("X2")
                jData.Add("TIME_WINDOW", reg)
            Case Else
                'Misc
                reg = Read(STATUS_REG_AUX).ToString("X2")
                jData.Add("STATUS_REG_AUX", reg)
                reg = Read(WHO_AM_I).ToString("X2")
                jData.Add("WHO_AM_I", reg)
                reg = Read(TEMP_CFG).ToString("X2")
                jData.Add("TEMP_CFG", reg)
                reg = Read(REF_DATA_CAP).ToString("X2")
                jData.Add("REF_DATA_CAP", reg)
                reg = Read(FIFO_CTRL).ToString("X2")
                jData.Add("FIFO_CTRL", reg)
                reg = Read(FIFO_SRC).ToString("X2")
                jData.Add("FIFO_SRC", reg)
                
                'Sleep mode settings
                reg = Read(ACT_THS).ToString("X2")
                jData.Add("ACT_THS", reg)
                reg = Read(ACT_DUR).ToString("X2")
                jData.Add("ACT_DUR", reg)
        End Select
        Return jData
    End Function
    
    'See Setup -default enable all axes
    Public Sub Setup(operating_mode As Byte, data_rate As Byte, scale As Byte)
        Setup(operating_mode, data_rate, scale, (X_AXIS | Y_AXIS | Z_AXIS))
    End Sub
    
    
    '    Setup - setup the accelerometer to be able to retreive accelerometer data
    '    
    '    operating_mode As Byte - operating mode of the accelerometer (LOW_POWER_MODE, NORMAL_MODE, HIGH_RESOLUTION_MODE)
    '    data_rate As Byte - data rate for the accelerometer (DATA_RATE_POWER_DOWN, DATA_RATE_1HZ, DATA_RATE_10HZ, DATA_RATE_25HZ, DATA_RATE_50HZ, DATA_RATE_100HZ, DATA_RATE_200HZ, DATA_RATE_400HZ, DATA_RATE_1620HZ_LP, DATA_RATE_1344HZ)
    '    scale As Byte - scale of the accelerometer (+/-2G, +/-4G, +/-8G, +/-16G (SCALE_2G, SCALE_4G, SCALE_8G, SCALE_16G) 
    Public Sub Setup(operating_mode As Byte, data_rate As Byte, scale As Byte, axis As Byte)
        'set up values for accelerator
        'mode = NORMAL_MODE, LOW_POWER_MODE, HIGH_RESOLUTION_MODE
        'data_rate = DATA_RATE_100HZ etc
        'scale = SCALE_16G etc
        'axis = X_AXIS | Y_AXIS | Z_AXIS
        
        'reset accelerometer values to defaults.
        reset()
        
        EnableAxis(axis) 'enable selected axes  
        SetMode(operating_mode)    
        SetDataRate(data_rate)     
        SetScale(scale)
        
        'Set interrupt as active low
        SetIntLogic(True)
        'Set Block Data Update Mode (ensures data is syncronized)
        SetBlockData(BDU_BIT)
        
    End Sub
    
    '    ConfigureShockInterrupt - configures device to interrupt on shock (currently will interupt on any enabled axis, x,y,z)
    '    
    '    Inputs:
    '    threshold As Float - trigger threshold (0.0 Gs ~ 23.622 Gs), 16mg steps (depends on range and mode)
    '    Duration As Float - Duration for threshold to be present to active interrupt (0 ms (immediate) to 635ms), steps depends on ODR
    '    
    '    Returns:
    '    result As Boolean- False if function failed, True if function successful (MORE ERROR MESSAGES TO BE ADDED IN THE FUTURE)
    '    NW 19th Jan 2017 depreciated - repaced by ConfigureTransientInterrupt()
    Public Function ConfigureShockInterrupt(threshold As Float, duration As Float) As Boolean
        Return ConfigureTransientInterrupt(threshold, duration)    
    End Function
    
    Public Function ConfigureMotionInterrupt(threshold As Float, duration As Float) As Boolean
        Return ConfigureMotionInterrupt(threshold, duration, 1, 1, True)
    End Function
    
    Public Function ConfigureMotionInterrupt(threshold As Float, duration As Float, interrupt As Byte, IntPin As Byte, Latch As Boolean) As Boolean
        Return ConfigureMotionInterrupt(threshold, duration, interrupt, IntPin, Latch, (INT_SRC_XH | INT_SRC_YH | INT_SRC_ZH))
    End Function
    
    '    ConfigureMotionInterrupt - configures device to interrupt on motion
    '    NOTE: You can't actually detect motion as such (this is an accelerometer - it detects acceleration - not motion)
    '          but you could use it to trigger events - ie +ve accel  = motion start -ve accel  = motion stop
    '          default set up is only to detect +ve accel (INT_SRC_XH | INT_SRC_YH | INT_SRC_ZH | INT_SRC_XL | INT_SRC_YL | INT_SRC_ZL)
    '          would detect both +ve and -ve accel events.
    '    NOTE: Setup() MUST BE RUN PRIOR TO CALLING THIS FUNCTION
    '
    '    Inputs:
    '    threshold As Float - trigger threshold (0.0 Gs ~ 23.622 Gs), 16mg steps (depends on range and mode)
    '    NOTE: This triggers on ABSOLUTE gravity measurements, earths gravity field is 1.0 G (aprox), if you set threshold below 1.0
    '          the interrupt will continually trigger when X,Y, or Z is horizontal (perpendicular to earths gravity).
    '          if you want to detect orientation, there is a special configuration for this. ConfigureOrientationInterrupt()
    '          will give you much better results.
    '    Duration As Float - Duration for threshold to be present to active interrupt (0 ms (immediate) to 635ms), steps depends on ODR
    '    interrupt - configure interrupt 1 or 2
    '    IntPin - output interrupt on pin 1 or 2
    '    Latch - True = Latch interrupt until INTX_SRC is read (where X is 1 or 2, whichever was configured)
    '    enabledInterrupts - axes you want to generate interrupts on eg INT_SRC_XH | INT_SRC_YH | INT_SRC_ZH or just INT_SRC_ZH (or INT_SRC_ZL if you want to detect passing below a threshold) 
    
    '    Returns:
    '    result As Boolean- False if function failed, True if function successful (MORE ERROR MESSAGES TO BE ADDED IN THE FUTURE)
    Public Function ConfigureMotionInterrupt(threshold As Float, duration As Float, interrupt As Byte, IntPin As Byte, Latch As Boolean, enabledInterrupts As Byte) As Boolean
        
        If GetDataRate() = DATA_RATE_POWER_DOWN Then 'setup not run, set some defaults
            Setup(LOW_POWER_MODE, DATA_RATE_200HZ, SCALE_16G)
        End If
        
        'set sleep mode
        SetSleepToWakeThreshold(threshold)
        SetSleepToWakeDuration(5000) //5 seconds in ms
        
        'configure interrupt to pin, and enable interrupt latching (has to be cleared by reading int source register).
        SetIntPinConfig(interrupt, IntPin, Latch)
        
        If interrupt = 1 Then
            'Set Threshold 1.0 ~ 23.622 Gs
            SetINT1Threshold(threshold)
            'Set Duration (if set to 0, causes interrupt immediately, once threshold exceeded
            SetINT1Duration(duration)
            'Configure device to generate interrupt on configure events (usually all three axes high INT_SRC_XH | INT_SRC_YH | INT_SRC_ZH )
            SetINT1ActiveInterrupt(enabledInterrupts)
        Else
            'Set Threshold 1.0 ~ 23.622 Gs
            SetINT2Threshold(threshold)
            'Set Duration (if set to 0, causes interrupt immediately, once threshold exceeded
            SetINT2Duration(duration)
            'Configure device to generate interrupt on configure events (usually all three axes high INT_SRC_XH | INT_SRC_YH | INT_SRC_ZH )
            SetINT2ActiveInterrupt(enabledInterrupts)
        End If
        
    End Function
    
    Public Function ConfigureTransientInterrupt(threshold As Float, duration As Float) As Boolean
        Return ConfigureTransientInterrupt(threshold, duration, 1, 1, True)
    End Function
    
    Public Function ConfigureTransientInterrupt(threshold As Float, duration As Float, interrupt As Byte, IntPin As Byte, Latch As Boolean) As Boolean
        Return ConfigureTransientInterrupt(threshold, duration, interrupt, IntPin, Latch, (INT_SRC_XH | INT_SRC_YH | INT_SRC_ZH))
    End Function
    
    '    ConfigureTransientInterrupt - configures device to interrupt on transient
    '    NOTE: Setup() MUST BE RUN PRIOR TO CALLING THIS FUNCTION
    '
    '    Inputs:
    '    threshold As Float - trigger threshold (0.0 Gs ~ 23.622 Gs), 16mg steps (depends on range and mode)
    '    Duration As Float - Duration for threshold to be present to active interrupt (0 ms (immediate) to 635ms), steps depends on ODR
    '    interrupt - configure interrupt 1 or 2
    '    IntPin - output interrupt on pin 1 or 2
    '    Latch - True = Latch interrupt until INTX_SRC is read (where X is 1 or 2, whichever was configured)
    '    enabledInterrupts - axes you want to generate interrupts on eg INT_SRC_XH | INT_SRC_YH | INT_SRC_ZH or just INT_SRC_ZH (or INT_SRC_ZL if you want to detect passing below a threshold) 
    
    
    '    Returns:
    '    Nothing
    Public Function ConfigureTransientInterrupt(threshold As Float, duration As Float, interrupt As Byte, IntPin As Byte, Latch As Boolean, enabledInterrupts As Byte) As Boolean
        
        If GetDataRate() = DATA_RATE_POWER_DOWN Then 'setup not run, set some defaults
            Setup(LOW_POWER_MODE, DATA_RATE_200HZ, SCALE_16G)
        End If
        
        'set sleep mode
        SetSleepToWakeThreshold(threshold)
        SetSleepToWakeDuration(5000) //5 seconds in ms
        
        'configure interrupt to pin, and enable interrupt latching (has to be cleared by reading int source register).
        SetIntPinConfig(interrupt, IntPin, Latch)
        
        'HP filter config
        'SetFilterMode(HP_FILTER_NORMAL_MODE_AUTO) //HP Filter auto reset on interrupt
        SetFilterRange(HP_CUTOFF_HIGH)
        
        If interrupt = 1 Then
            'Enable HP Filter
            SetFilterAOI1(True) //HP Filter Interrupt on INT1
            'Set Threshold 0.0 ~ 23.622 Gs
            SetINT1Threshold(threshold)
            'Set Duration (if set to 0, causes interrupt immediately, once threshold exceeded
            SetINT1Duration(duration)
            'dummy read of REF_DAT_CAP to reset HP filter
            GetRefDataCap()
            'Configure device to generate interrupt on configure events (usually all three axes high INT_SRC_XH | INT_SRC_YH | INT_SRC_ZH )
            SetINT1ActiveInterrupt(enabledInterrupts)
        Else
            'Enable HP Filter
            SetFilterAOI2(True) //HP Filter Interrupt on INT2
            'Set Threshold 0.0 ~ 23.622 Gs
            SetINT2Threshold(threshold)
            'Set Duration (if set to 0, causes interrupt immediately, once threshold exceeded
            SetINT2Duration(duration)
            'dummy read of REF_DAT_CAP to reset HP filter
            GetRefDataCap()
            'Configure device to generate interrupt on configure events (usually all three axes high INT_SRC_XH | INT_SRC_YH | INT_SRC_ZH )
            SetINT2ActiveInterrupt(enabledInterrupts)
        End If
        
    End Function
    
    Public Function ConfigureFreeFallInterrupt() As Boolean
        Return ConfigureFreeFallInterrupt(0.35, 20.0, 1, 1, True)
    End Function
    
    Public Function ConfigureFreeFallInterrupt(threshold As Float, duration As Float) As Boolean
        Return ConfigureFreeFallInterrupt(threshold, duration, 1, 1, True)
    End Function
    
    '    ConfigureFreeFallInterrupt - configures device to interrupt on free fall (currently will interupt on any enabled axis)
    '    NOTE: Setup() MUST BE RUN PRIOR TO CALLING THIS FUNCTION
    '
    '    Inputs:
    '    threshold As Float - trigger threshold (0.0 Gs ~ 23.622 Gs), 16mg steps (depends on range and mode)
    '    Duration As Float - Duration for threshold to be present to active interrupt (0 ms (immediate) to 635ms), steps depends on ODR
    '    interrupt - configure interrupt 1 or 2
    '    IntPin - output interrupt on pin 1 or 2
    '    Latch - True = Latch interrupt until INTX_SRC is read (where X is 1 or 2, whichever was configured)
    '    
    '    Returns:
    '    Nothing
    Public Function ConfigureFreeFallInterrupt(threshold As Float, duration As Float, interrupt As Byte, IntPin As Byte, Latch As Boolean) As Boolean
        
        If GetDataRate() = DATA_RATE_POWER_DOWN Then 'setup not run, set some defaults
            Setup(LOW_POWER_MODE, DATA_RATE_200HZ, SCALE_16G)
        End If
        
        'set sleep mode
        SetSleepToWakeThreshold(threshold)
        SetSleepToWakeDuration(5000) //5 seconds in ms
        
        'configure interrupt to pin, and enable interrupt latching (has to be cleared by reading int source register).
        SetIntPinConfig(interrupt, IntPin, Latch)
        
        If interrupt = 1 Then
            'Set Threshold 0.0 ~ 23.622 Gs
            SetINT1Threshold(threshold)
            'Set Duration (if set to 0, causes interrupt immediately, once threshold exceeded
            SetINT1Duration(duration)
            'Configure device to generate interrupt on X, Y, AND Z low event (with INT_AOI_BIT, interrupts are ANDED)
            'so X, Y and Z have to go below threshold to trigger event.
            SetINT1ActiveInterrupt(INT_SRC_XL | INT_SRC_YL | INT_SRC_ZL | INT_AOI_BIT)
        Else
            'Set Threshold 0.0 ~ 23.622 Gs
            SetINT2Threshold(threshold)
            'Set Duration (if set to 0, causes interrupt immediately, once threshold exceeded
            SetINT2Duration(duration)
            'Configure device to generate interrupt on X, Y, AND Z low event (with INT_AOI_BIT, interrupts are ANDED)
            'so X, Y and Z have to go below threshold to trigger event.
            SetINT2ActiveInterrupt(INT_SRC_XL | INT_SRC_YL | INT_SRC_ZL | INT_AOI_BIT)
        End If
        
    End Function
    
    Public Function ConfigureSingleClickInterrupt() As Boolean
        Return ConfigureClickInterrupt(0.15, 100.0, 0, 0, (ZS), True, 1)
    End Function
    
    Public Function ConfigureDoubleClickInterrupt() As Boolean
        Return ConfigureClickInterrupt(0.15, 100.0, 40.0, 200.0, (ZD), True, 1)
    End Function
    
    Public Function ConfigureSingleDoubleClickInterrupt() As Boolean
        Return ConfigureClickInterrupt(0.15, 100.0, 40.0, 200.0, (ZS | ZD), True, 1)
    End Function
    
    '    ConfigureClickInterrupt - configures device to interrupt on clicks (currently will interupt on any enabled axis)
    '    NOTE: Setup() MUST BE RUN PRIOR TO CALLING THIS FUNCTION
    '    NOTE: When CLICK interrupt is generated, it can only be cleared by reading the CLICK_SRC register (see GetIntClickSource())
    '
    '    Inputs:
    '    threshold As Float - trigger threshold (0.0 Gs ~ 23.622 Gs), 16mg steps (depends on range and mode)
    '    Duration As Float - Duration for threshold to be present to active interrupt (0 ms (immediate) to 635ms), steps depends on ODR
    '    latency As Float - Duration between double clicks (clicks within the period are not reconized)
    '    window As Float - Duration diring which a second click must be detected to count as double click (after latency period has expired)
    '    click As Byte - Enable/Disable Single_click detection as follows:
    '    (ZD | ZS | YD |YS |XD |XS) - where S is single and D is double click enabled.
    '    NOTE: one of the above should be enabled!
    '    filter - True = HP filter enabled
    '    IntPin - output interrupt on pin 1 or 2
    '    
    '    Returns:
    '    Nothing
    Public Function ConfigureClickInterrupt(threshold As Float, duration As Float, latency As Float, window As Float, click As Byte, filter As Boolean, IntPin As Byte) As Boolean
        
        If GetDataRate() = DATA_RATE_POWER_DOWN Then 'setup not run, set some defaults
            Setup(LOW_POWER_MODE, DATA_RATE_200HZ, SCALE_16G)
        End If
        
        'set sleep mode
        SetSleepToWakeThreshold(threshold)
        SetSleepToWakeDuration(5000) //5 seconds in ms
        
        If filter Then
            SetFilterClick(True) 'enable HP filter for Click
        End If
        
        If IntPin = 1 Then
            'Add Click interrupt on INT1
            SetPin1Interrupts(GetPin1Interrupts() | INT1_CLICK_BIT)
        Else
            'Add CLICK interrupt on INT2 Pin
            SetCTL6Bits(GetCTL6Bits() | I2_CLICKen)
        End If
        
        'Set Threshold 0.0 ~ 23.622 Gs
        SetClickThreshold(threshold)
        'Latch interrupt until read.
        SetClickLatch(True)
        'Set Duration - this sets the time that the click must end within to count - NOTE! different from normal duration
        SetClickDuration(duration)
        'below two settings are double click settings only!
        SetClickLatency(latency) 'time windo during no click will be detected after a single click
        SetClickTimeWindow(window) ' time period during which a seond click must be detected to count (after latency)
        'Configure click interrupts (set single or double click for axes)
        SetClickConfig(click)
        
    End Function
    
    Public Function ConfigureOrientationInterrupt() As Boolean
        'detect change in orientation (for more than 160ms) all axes, INT1 pin 1, single interrupt on change
        Return ConfigureOrientationInterrupt(0.5, 160.0, False, False, 1, 1)
    End Function
    
    Public Function ConfigurePLInterrupt() As Boolean
        'Portrate/Landscape Orientation detection, INT1 pin 1, single interrupt on change
        Return ConfigureOrientationInterrupt(0.7, 160.0, False, True, 1, 1)
    End Function
    
    Public Function ConfigureGarageDoorInterrupt() As Boolean
        'Garage Door Orientation detection, 10Hz, 500ms Duration, INT1 pin 1, single interrupt on change
        'detect bottom/down, or bottom/up depending on module orientation
        Setup(LOW_POWER_MODE, DATA_RATE_10HZ, SCALE_2G)
        Return ConfigureOrientationInterrupt(0.7, 500.0, False, False, 1, 1)
    End Function
    
    '    ConfigureOrientationInterrupt - configures device to interrupt on orientation changes
    '    can be set for x,y,z or just x and y
    '    NOTE: Setup() MUST BE RUN PRIOR TO CALLING THIS FUNCTION
    '    NOTE: to decode orientation, read GetInt1Orientation(), or GetInt2Orientation() (for int 1 or 2)
    '    NOTE: Interrupts do not latch in 6D orientation mode.
    '
    '    Inputs:
    '    threshold As Float - trigger threshold (0.0 Gs ~ 1.0 Gs),set to 0.5g normally = 30 degrees (governs where change of orientation is detected)
    '    Duration As Float - Duration for threshold to be present to active interrupt (0 ms (immediate) to 635ms), steps depends on ODR
    '    pos_motion As Boolean - set to True to detect stable position, False to detect change in position.
    '    disable_z As Boolean - True disables Z orientation detection (4D mode), False is 6D mode
    '    interrupt - configure interrupt 1 or 2
    '    IntPin - output interrupt on pin 1 or 2
    
    '    NOTE: In Position (stable position) mode, the interrupt is continuous while orientation remains the same. In movement (change in position) mode, the Interrupt is generated for 1/ODR cycle.
    '    NOTE: pos_motion = True (stable position mode) will continuously generate interrupts, which will prevent your module from sleeping, and will run your battery down fast!
    '    
    '    Returns:
    '    Nothing
    Public Function ConfigureOrientationInterrupt(threshold As Float, duration As Float, pos_motion As Boolean, disable_z As Boolean, interrupt As Byte, IntPin As Byte) As Boolean
        
        If GetDataRate() = DATA_RATE_POWER_DOWN Then 'setup not run, set some defaults
            Setup(LOW_POWER_MODE, DATA_RATE_25HZ, SCALE_2G)
        End If
        
        'set sleep mode
        SetSleepToWakeThreshold(threshold)
        SetSleepToWakeDuration(5000) //5 seconds in ms
        
        'configure interrupt to pin.
        SetIntPinConfig(interrupt, IntPin, False) 'note interrupts do not latch in 6D mode (I think, the DS is confusing on this point)
        
        Dim Axes As Byte = (INT_SRC_XH | INT_SRC_XL | INT_SRC_YH | INT_SRC_YL | INT_6D_BIT)
        If Not disable_z Then
            Axes = Axes | INT_SRC_ZH | INT_SRC_ZL
        End If
        If pos_motion Then
            Axes = Axes | INT_AOI_BIT 'enable position (rather than motion sensing) - interrupts are continuous in this mode
        End If
        
        If interrupt = 1 Then
            'Enable/disable Z axis (6D/4D mode)
            If disable_z Then
                SetCTL5Bits(GetCTL5Bits() | D4D_INT1)
            End If
            'Set Threshold 0.0 ~ 1.0 Gs
            SetINT1Threshold(threshold)
            'Set Duration (if set to 0, causes interrupt immediately, once threshold exceeded
            SetINT1Duration(duration)
            'enable interrupts
            SetINT1ActiveInterrupt(Axes)
        Else
            'Enable/disable Z axis (6D/4D mode)
            If disable_z Then
                SetCTL5Bits(GetCTL5Bits() | D4D_INT2)
            End If
            'Set Threshold 0.0 ~ 1.0 Gs
            SetINT2Threshold(threshold)
            'Set Duration (if set to 0, causes interrupt immediately, once threshold exceeded
            SetINT2Duration(duration)
            'enable interrupts
            SetINT2ActiveInterrupt(Axes)
        End If
        
    End Function
    
    'GetAccelLowPassFilter - returns the acceleration data for x,y,z low pass filtered by factor alpha
    'uses global Public values x,y,x_filtered
    'Alpha - smoothing factor in range 0.0-1.0
    '
    'Returns:
    'returns the filtered x,y,z values As ListOfFloat
    Public x_filtered As Float
    Public y_filtered As Float
    Public z_filtered As Float
    
    Public Function GetAccelLowPassFilter(alpha As Float) As ListOfFloat
        If alpha > 1.0 Then
            alpha = 1.0
        ElseIf alpha <= 0 Then
            alpha = 0.1
        End If
        
        Dim result As ListOfFloat = New ListOfFloat
        Dim accelValues As ListOfFloat = GetAccel()
        
        //Low Pass Filter
        x_filtered = accelValues(0) * alpha + (x_filtered * (1.0 - alpha))
        y_filtered = accelValues(1) * alpha + (y_filtered * (1.0 - alpha))
        z_filtered = accelValues(2) * alpha + (z_filtered * (1.0 - alpha))
        
        result.Add(x_filtered)
        result.Add(y_filtered)
        result.Add(z_filtered)
        Return result
    End Function
    
    Public Function atan2(y As Float, x As Float) As Float
        'If no errors occur, the arc tangent of y/x (arctan(y/x)) in the range [0,2π] radians, is returned
        Dim result As Float
        result = (y / x).ATan()
        If x < 0 Then
            result += Float.Pi
        Else
            If y < 0 Then
                result += 2 * Float.Pi
            End If
        End If
        Return result
    End Function
    
    Public Function GetPitchRoll() As ListOfFloat
        'get unfiltered pitch and roll values
        Return GetPitchRoll(1.0)
    End Function
    
    'GetPitchRoll - returns the pitch and roll in Radians
    '
    'Returns:
    'returns the pitch and roll in radians As ListOfFloat
    'NOTE: returns pitch/roll as +/90 degrees values, and as 0-360 degrees values
    '      return(0)-(1) = +/- 90, (2)-(3) = 0-360
    Public Function GetPitchRoll(alpha As Float) As ListOfFloat
        'get pitch and roll in Radians
        'need all three axes enabled for this calculation
        'from ST Application Note D026445 Rev 1
        'also roll  = atan2(Ax,Az)  * RAD_TO_DEG
        '     pitch = atan2(Ay,Az)  * RAD_TO_DEG
        
        Dim result As ListOfFloat = New ListOfFloat
        Dim Pitch As Float = Float.NaN
        Dim Roll As Float = Float.NaN
        Dim Pitch1 As Float = Float.NaN
        Dim Roll1 As Float = Float.NaN
        Dim accelValues As ListOfFloat = GetAccelLowPassFilter(alpha)
        
        If accelValues <> Nothing Then
            Pitch = (accelValues(0) / (accelValues(1).Pow(2.0) + accelValues(2).Pow(2.0)).Sqrt()).ATan()
            Roll = (accelValues(1) / (accelValues(0).Pow(2.0) + accelValues(2).Pow(2.0)).Sqrt()).ATan() 'gives same values as below
            'Pitch = (accelValues(0) / accelValues(2)).ATan()
            'Roll = (accelValues(1) / accelValues(2)).ATan()
            Pitch1 = atan2(accelValues(0), accelValues(2))
            'Roll1 = atan2(accelValues(1), (accelValues(1).Pow(2.0) + accelValues(2).Pow(2.0)).Sqrt())
            Roll1 = atan2(accelValues(1), accelValues(2))
        End If
        result.Add(Pitch)
        result.Add(Roll)
        result.Add(Pitch1)
        result.Add(Roll1)
        Return result
    End Function
    
    Public Function GetPitchRollDegrees() As ListOfFloat
        'get unfiltered pitch and roll values in degrees
        Return GetPitchRollDegrees(1.0)
    End Function
    
    'GetPitchRoll - returns the pitch and roll in degrees
    'Returns:
    'returns the pitch and roll in degrees As ListOfFloat
    Public Function GetPitchRollDegrees(alpha As Float) As ListOfFloat
        Dim result As ListOfFloat = New ListOfFloat
        Dim PitchRoll As ListOfFloat = GetPitchRoll(alpha)
        Dim Pitch As Float = Float.NaN
        Dim Roll As Float = Float.NaN
        Dim RollAlt As Float = Float.NaN
        
        For Each angle In PitchRoll
            Dim degreees As Float = Float.NaN
            If angle <> Float.NaN Then
                degreees = angle * (180.0 / Float.Pi)
            End If
            result.Add(degreees)
        Next
        
        Return result
    End Function
    
    Public Function GetAccelG() As ListOfFloat
        'get x,y,z accel data as G
        Return GetAccelG(1.0)
    End Function
    
    Public Function GetAccelG(alpha As Float) As ListOfFloat
        'get x,y,z accel data low pass filtered as G
        Dim accelValues As ListOfFloat = GetAccelLowPassFilter(alpha)
        Dim gravity As Float = 9.81 '(aprox m/s2)
        Dim Result As ListOfFloat = New ListOfFloat
        
        Dim xG As Float = accelValues(0) * gravity
        Dim yG As Float = accelValues(1) * gravity
        Dim zG As Float = accelValues(2) * gravity
        
        Result.Add(xG)
        Result.Add(yG)
        Result.Add(zG)
        
        Return Result
    End Function
    
    Public Function GetAccel(alpha As Float) As ListOfFloat
        'get x,y,z accel data low pass filtered
        Return GetAccelLowPassFilter(alpha)
    End Function
    
    'GetAccel - returns the acceleration of all axis
    'NOTE: Setup() MUST BE RUN PRIOR TO CALLING THIS FUNCTION
    '
    'Returns:
    'returns the acceleration value in Gs As ListOfFloat
    Public Function GetAccel() As ListOfFloat
        'Returns the acceleration reading of the specified axis in Gs
        'Z-axis acceleration data. The value is expressed as two’s complement left-justified.
        If GetDataRate() = DATA_RATE_POWER_DOWN Then 'setup not run, set some defaults
            Setup(LOW_POWER_MODE, DATA_RATE_200HZ, SCALE_16G)
        End If
        
        Dim scaleFactor As Float = 0.0
        Dim XaccelerationReading As Short = 0
        Dim YaccelerationReading As Short = 0
        Dim ZaccelerationReading As Short = 0
        Dim accelX As Float = 0
        Dim accelY As Float = 0
        Dim accelZ As Float = 0
        Dim acceleration As ListOfFloat = New ListOfFloat // x/y/z accel output data stored here
        
        Dim scale As Byte = GetScale()
        Dim mode As Byte = GetMode()
        
        
        Select scale
            Case SCALE_2G
                scaleFactor = 0.001 '1mg per bit
            Case SCALE_4G
                scaleFactor = 0.002 '2mg per bit
            Case SCALE_8G
                scaleFactor = 0.004 '4mg per bit
            Case SCALE_16G
                scaleFactor = 0.012 '12mg per bit
        End Select
        
        
        'read acceleration registers
        Dim Data As ListOfByte = readAccelDataBytes()
        
        Select mode
            Case LOW_POWER_MODE
                '8 bit signed
                XaccelerationReading = Data(1)
                YaccelerationReading = Data(3)
                ZaccelerationReading = Data(5) 
                If ((Data(1) & 0x80) = 0x80) Then
                    'negative number
                    XaccelerationReading = (Data(1) ^ 0xff) * -1             
                End If
                If ((Data(3) & 0x80) = 0x80) Then
                    'negative number
                    YaccelerationReading = (Data(3) ^ 0xff) * -1                
                End If
                If ((Data(5) & 0x80) = 0x80) Then
                    'negative number
                    ZaccelerationReading = (Data(5) ^ 0xff) * -1                 
                End If
                'convert to acceleration
                accelX = XaccelerationReading * scaleFactor * LP_FACTOR
                accelY = YaccelerationReading * scaleFactor * LP_FACTOR
                accelZ = ZaccelerationReading * scaleFactor * LP_FACTOR
                
            Case NORMAL_MODE
                '10 bit signed            
                XaccelerationReading = ((Data(1) << 8) | Data(0)) >> 6
                YaccelerationReading = ((Data(3) << 8) | Data(2)) >> 6
                ZaccelerationReading = ((Data(5) << 8) | Data(4)) >> 6
                If ((XaccelerationReading & 0x0200) = 0x0200) Then
                    'negative number
                    XaccelerationReading = (XaccelerationReading ^ 0x03ff) * -1
                End If
                If ((YaccelerationReading & 0x0200) = 0x0200) Then
                    'negative number
                    YaccelerationReading = (YaccelerationReading ^ 0x03ff) * -1
                End If      
                If ((ZaccelerationReading & 0x0200) = 0x0200) Then
                    'negative number
                    ZaccelerationReading = (ZaccelerationReading ^ 0x03ff) * -1
                End If
                'convert to acceleration        
                accelX = XaccelerationReading.ToFloat* scaleFactor * NM_FACTOR
                accelY = YaccelerationReading.ToFloat* scaleFactor * NM_FACTOR
                accelZ = ZaccelerationReading.ToFloat* scaleFactor * NM_FACTOR
                
            Case HIGH_RESOLUTION_MODE
                '12 bit signed
                XaccelerationReading = ((Data(1) << 8) | Data(0)) >> 4
                YaccelerationReading = ((Data(3) << 8) | Data(2)) >> 4
                ZaccelerationReading = ((Data(5) << 8) | Data(4)) >> 4
                If ((XaccelerationReading & 0x0800) = 0x0800) Then
                    'negative number
                    XaccelerationReading = (XaccelerationReading ^ 0x0fff) * -1
                End If
                If ((YaccelerationReading & 0x0800) = 0x0800) Then
                    'negative number
                    YaccelerationReading = (YaccelerationReading ^ 0x0fff) * -1
                End If
                If ((ZaccelerationReading & 0x0800) = 0x0800) Then
                    'negative number
                    ZaccelerationReading = (ZaccelerationReading ^ 0x0fff) * -1
                End If
                'convert to acceleration        
                accelX = XaccelerationReading.ToFloat* scaleFactor
                accelY = YaccelerationReading.ToFloat* scaleFactor
                accelZ = ZaccelerationReading.ToFloat* scaleFactor
        End Select
        
        acceleration.Add(accelX)
        acceleration.Add(accelY)
        acceleration.Add(accelZ)
        
        Return acceleration
        
    End Function
    
    'Accel - returns the acceleration of the specified axis NOTE: Setup() MUST BE RUN PRIOR TO CALLING THIS FUNCTION
    '
    'Inputs:
    'xyz As Byte - axis of acceleration to return (X_AXIS, Y_AXIS, Z_AXIS)
    '
    'Returns:
    'returns the acceleration value in Gs As Float
    Public Function Accel(xyz As Byte) As Float
        If GetDataRate() = DATA_RATE_POWER_DOWN Then 'setup not run, set some defaults
            Setup(LOW_POWER_MODE, DATA_RATE_200HZ, SCALE_16G)
        End If
        
        Dim accelValues As ListOfFloat = GetAccel()
        If accelValues = Nothing Then
            Return Nothing
        End If
        
        Select xyz
            Case X_AXIS
                Return accelValues(0)
            Case Y_AXIS
                Return accelValues(1)
            Case Z_AXIS
                Return accelValues(2)
            Case Else
                Return Nothing
        End Select
        
    End Function
    
    
    'GetID() - returns the ID of the LISDH12
    '
    'Inputs: NONE
    '
    'Returns:
    'returns the ID of the LISDH12, should be 0x33 if device is powered on (takes 5ms to boot)
    Public Function GetID() As Byte
        Return Read(WHO_AM_I)
    End Function
    
    Private Function Read(address As Byte) As Byte
        Dim result As Byte = 0
        Dim value As ListOfByte = Read(address, 1) // Read single byte
        
        If value <> Nothing Then
            result = value(0)
        End If
        Return result
    End Function // Read
    
    
    Private Function Read(address As Byte, length As Byte) As ListOfByte
        Dim data As ListOfByte = New ListOfByte
        
        data.Add(address | 0x80) '0x80 allows sequential reading of addresses
        gAccelerometer.Write(data, False)
        
        Return gAccelerometer.Read(length, True)
    End Function // Read
    
    
    Private Function Write(address As Byte, value As Byte) As Boolean
        Dim data As ListOfByte = New ListOfByte
        
        data.Add(value)
        
        Return Write(address, data) // Write single byte
    End Function // Write
    
    
    Private Function Write(address As Byte, values As ListOfByte) As Boolean
        values.InsertAt(0, address | 0x80) '0x80 allows sequential writing of addresses
        
        Return gAccelerometer.Write(values, True)
    End Function // Write
    
    'GetVersion() - returns version of this driver
    '
    'Inputs: NONE
    '
    'Returns:
    'version As Integer - returns the version of the driver
    Public Function GetVersion() As Integer
        Return VERSION
    End Function
    
End Class